#!/bin/sh -e

BASE_DIR=$(pwd)
RES_DIR="$BASE_DIR"/resources
TOOL_FILES="$BASE_DIR"/.tool-files
LOGFILE="tool.log"
RED='\033[0;31m'; YEL='\033[1;33m'; GRN='\033[0;32m'
NC='\033[0m' # No Color
B='\033[1m'; U='\033[4m'
VER="1.1p(0904 last checked with OpenCore version DBG-050-2019-09-03"
SILENT=""
VERBOSE=""
UPDATE=""
BUILD_ALL=""
REMOVE_ALL=""
BASE_TOOLS=""


args=$(getopt hsuvAVX "$@")
set -- $args

msg() {
	if [ -z "$SILENT" ]; then
		echo "$1\c" >"$(tty)"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR"/BOOT
	mkdir -p "$BUILD_DIR"/OC
	fin
}

inc_res_num() {
	res_num=$((res_num+1))
}

init_res_array() {
	res_list="base,https://github.com/acidanthera/EfiPkg,,,"
	res_list="${res_list}base,https://github.com/acidanthera/MacInfoPkg,,,"
	res_list="${res_list}base,https://github.com/acidanthera/OcSupportPkg,,,"
	res_list="${res_list}BOOTx64.efi,https://github.com/acidanthera/OpenCorePkg,,BOOT,"
	res_list="${res_list}OpenCore.efi,https://github.com/acidanthera/OpenCorePkg,,OC,"
	res_list="${res_list}config.plist,,$BASE_DIR/$AUDK_CONFIG,OC,"
	res_num=0
	IFS=","
	for line in $res_list # $(echo $res_list|tr ',' '\n')
	do
		inc_res_num
		eval arr$res_num="$line"
	done
	unset IFS
	unset res_list
}

clone() {
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		msg "Cloning $1 into $pkg_name ... "
		git clone $1 "$pkg_name"; fin
		echo "new" > "$pkg_name"/gitDEBUGsha
		echo "new" > "$pkg_name"/gitRELEASEsha
	fi
}

missing() {
	msg "\n${RED}ERROR:${NC} $1 not found, install it to continue\n"
	exit 1
}

check_requirements() {
	msg "\nChecking if required tools and files exist ..."
	command -v xcodebuild||missing "xcodebuild"
	command -v nasm||missing "nasm"
	command -v mtoc||missing "mtoc"
	command -v git||missing "git"
	fin
}

check_config() {
	if [ ! -f "$BASE_DIR/$CONFIG_PLIST" ]; then
		msg "\n${RED}ERROR: ${NC}$BASE_DIR/$CONFIG_PLIST does not exist\n\nPlease create this file and run the tool again.\n"
		exit 1
	fi
}

check_for_updates() {
	msg "\nChecking for updates ... \n"
	cd "$BASE_DIR"
	OLDVER=$(git rev-parse HEAD)
	git pull $VERBOSE
	if [ "$OLDVER" != "$(git rev-parse HEAD)" ]; then # new version of OpenCore-tool
		msg "${YEL}INFO:${NC} OpenCore-tool has been updated, run tool again to continue\n"
		exit 0
	fi
	if [ -d "$RES_DIR" ]; then
		cd "$RES_DIR" # now check all resources
		find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev|xargs -I {} git -C {} pull $VERBOSE
	fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
	. edksetup.sh
	make -C BaseTools
}

build_shell_tool() {
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/DEBUG_XCODE5/X64"
	if [ -f "$srce/Shell.efi" ]; then return 0; fi
	clone "https://github.com/tianocore/edk2 -b UDK2018 --depth=1" "UDK"
	cd UDK
	msg "Making UDK2018 BaseTools ... "
	make_base_tools; fin

	msg "Patching UDK2018 ... "
	for p in ../Patches/* ; do
		git apply "$p"||echo "$p ignored, does not apply or alread done"
	done; fin

	msg "Building Shell.efi (OpenCoreShell.efi) ... "
	build -a X64 -b DEBUG -t XCODE5 -p ShellPkg/ShellPkg.dsc
	fin
}

build_failed() {
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n\tsee $LOGFILE for details\n"
	exit 1
}

xcode_build_loop() {
	a=1
	passed=""
	while [ -z "$passed" ]
	do
		passed="true"
		xcodebuild -config "$1" build||passed=""
		if [ -z "$passed" ]; then
			if [ "$a" -eq "6" ]; then
				build_failed
			fi
			msg "\n${YEL}$pkg_name BUILD $a FAILED:${NC} backing up one commit, trying again\n"
			git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		fi
	done
	if [ "$a" -ne "1" ]; then
		git checkout master
	fi
}

build_kext() {
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ]; then
		msg "Building $pkg_name ... "
		if [ "$pkg_name" = "Lilu" ] && [ "$AUDK_CONFIG" != "DEBUG" ]; then
			if [ "$(git rev-parse HEAD)" != "$(cat gitDEBUGsha)" ]; then
				msg "DEBUG ... "
				xcode_build_loop "Debug" #special case, always build DEBUG lilu
				git rev-parse HEAD > gitDEBUGsha
				fin
				msg "Building Lilu ... RELEASE ... "
			fi
		else
			rm -rf Lilu.kext # remove Lilu if it came from repo
			if [ ! -L "Lilu.kext" ]; then #link to acidanthera/Lilu debug version
				ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .
			fi
		fi
		xcode_build_loop "$XCODE_CONFIG"
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then #copy Products contents back to build level
			cp -r build/Products/* build
		fi
		fin
	fi
}

build_driver() {
	cd "$RES_DIR"/UDK
	clone "$git_url"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ]; then
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then
				msg "Making base tools ... "
				cd ..
				make_base_tools
				fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=0
			while :
			do
				a=$((a+1))
				if [ "$a" -eq "6" ]; then
					git checkout master
					return 1
				fi
				passed=""
				msg "Building $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc||passed="false"
				if [ -z "$passed" ]; then break; fi
				msg "${YEL}BUILD $a FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

build_resources() {
	msg "\n${GRN}Building needed or updated ${YEL}${AUDK_CONFIG}${GRN} resources${NC}\n"
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	clone "https://github.com/acidanthera/audk" "UDK"
	i=1
	while [ "$i" -lt "$res_num" ]
	do
		res_name=$(eval echo "\$arr$((i))")
		git_url=$(eval echo "\$arr$((i+1))")
		srce=$(eval echo "\$arr$((i+2))")
		if [ -z "$srce" ]; then
			case "$(echo "$res_name"|rev|cut -f 1 -d .|rev)" in
			"base" | "efi" )
				if [ "$res_name" = "Shell.efi" ]; then #special case
					build_shell_tool||build_failed
					eval arr$((i+2))="$srce"
				else
					build_driver||build_failed
					eval arr$((i+2))="$RES_DIR/UDK/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
				fi
				;;
			"kext" )
				build_kext||build_failed
				eval arr$((i+2))="$RES_DIR/Kext_builds/$pkg_name/build/$XCODE_CONFIG"
				;;
			esac
		fi
		i=$((i+4))
	done
	msg "\n"
}

copy_resources() {
	msg "\n${GRN}Moving resources into place${NC}\n"
	n=1
	while [ "$n" -lt "$res_num" ]
	do
		res_name=$(eval echo "\$arr$n"); n=$((n+2))
		srce=$(eval echo "\$arr$n"); n=$((n+1))
		dest=$(eval echo "\$arr$n"); n=$((n+1))
		if [ -n "$dest" ]; then
			msg "Copying $res_name to $dest ... "
			mkdir -p "$BUILD_DIR"/"$dest"
			cp -r "$srce"/"$res_name" "$BUILD_DIR"/"$dest"
			fin
		fi
	done
}

config_changed() {
	mkdir -p "$BASE_DIR"/Docs
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist
	msg "\n${YEL}WARNING:${NC} Sample$1.plist has been updated\n${YEL}!!!${NC} Make sure $BASE_DIR/$CONFIG_PLIST is up to date${NC}.\nRun the tool again if you make any changes.\n"
	cfg_ok="false"
}


check_if_Sample_plist_updated() {
	cfg_ok=""
	msg "\nChecking if config.plist format has changed ... "
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist||config_changed
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist||config_changed "Full"
	if [ -z "$cfg_ok" ]; then
		fin
	fi
}

build_vault() {
	use_vault=$(/usr/libexec/PlistBuddy -c "print :Misc:Security:RequireVault" "$BASE_DIR"/"$CONFIG_PLIST")||use_vault="false"
	if [ "$use_vault" = "true" ]; then
		msg "\nBuilding vault files for $BUILD_DIR ... "
		cd "$BUILD_DIR"/OC
		if ls vault* 1> /dev/null 2>&1; then
			rm vault.*
		fi
		"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .
		make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool
		"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub
		str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
		off=$((str+16))
		dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count=520 conv=notrunc
		rm vault.pub
		fin
	fi
}

res_not_found() {
	msg "\n${RED}ERROR:${NC}\t$1 - repo was not found in tool-files/repo.plist\n\t$1 file not found in extras directory\n\tPlace $1 file in extras directory to continue\n"
}

clear_array() {
	n=1
	while [ "$n" -lt "$res_num" ]
	do
		unset arr$n
		n=$((n+1))
	done
}

add_res_array() {
	git_url=$(/usr/libexec/PlistBuddy -c "print :$res_name" "$TOOL_FILES"/repo.plist)||git_url=""
	if [ -n "$git_url" ]; then
		srce=""
	elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
		srce="$BASE_DIR/extras"
	else
		res_not_found "$res_name"
		exit 1
	fi
	inc_res_num
	eval arr$res_num="$res_name"; inc_res_num
	eval arr$res_num="$git_url"; inc_res_num
	eval arr$res_num="$srce"; inc_res_num
	eval arr$res_num="$dest"
}

add_drivers_res_list() {
	n=0
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(/usr/libexec/PlistBuddy -c "print :UEFI:Drivers:$n" "$BASE_DIR"/"$CONFIG_PLIST")||res_name=""
		if [ "$res_name" != "" ]; then
			dest="/OC/Drivers"
			add_res_array
		fi
		n=$((n+1))
	done
}

add_kexts_res_list() {
	n=0
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(/usr/libexec/PlistBuddy -c "print :Kernel:Add:$n:BundlePath" "$BASE_DIR"/"$CONFIG_PLIST")||res_name=""
		Enabled=$(/usr/libexec/PlistBuddy -c "print :Kernel:Add:$n:Enabled" "$BASE_DIR"/"$CONFIG_PLIST")||Enabled=""
		if [ "$Enabled" = "true" ]; then
			dest="OC/Kexts"
			add_res_array
		fi
		n=$((n+1))
	done
}

add_tools_res_list() {
	n=0
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(/usr/libexec/PlistBuddy -c "print :Misc:Tools:$n:Path" "$BASE_DIR"/"$CONFIG_PLIST")||res_name=""
		Enabled=$(/usr/libexec/PlistBuddy -c "print :Misc:Tools:$n:Enabled" "$BASE_DIR"/"$CONFIG_PLIST")||Enabled=""
		if [ "$Enabled" = "true" ]; then
			dest="OC/Tools"
			add_res_array
		fi
		n=$((n+1))
	done
}

build_all_repos() {
	if [ -e "$TOOL_FILES/repo.plist" ]; then
		init_res_array
		res_name="Lilu.kext" #add Lilu before other kexts
		dest=""
		add_res_array

		for res_name in $(/usr/libexec/PlistBuddy -c "print" "$TOOL_FILES"/repo.plist|tr -d ' '|cut -s -f1 -d=)
		do
			if [ "$res_name" != "Lilu.kext" ]; then #Lilu already added, don't add it again
				add_res_array
			fi
		done

		build_resources
		clear_array
	else
		msg "${RED}ERROR:${NC} tool-files/repo.plist not found or invalid format\n"
		exit 1
	fi
	if [ "$BUILD_ALL" = "then exit" ]; then
		exit 0
	elif [ "$BUILD_ALL" = "both" ]; then
		ARG1="release"
		ARG2="release"
		BUILD_ALL="then exit"
		set_build_type
		build_all_repos # the magic of recursion
	fi
}

set_build_type() {
	case $ARG2 in
		d|debug)
			XCODE_CONFIG="Debug"
			;;
		r|release)
			XCODE_CONFIG="Release"
			;;
		*)
			msg "need to specify ${U}debug${NC} or ${U}release${NC} after $ARG1 command\n"
			exit 1
			;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	BUILD_DIR="$BASE_DIR/$AUDK_CONFIG/EFI"
	CONFIG_PLIST="$AUDK_CONFIG/config.plist"
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
	msg "\n${GRN}Setting up ${YEL}$AUDK_CONFIG${GRN} environment${NC}\n"
}


#****** Start build ***************
while :
do
	case  "$1" in
	-h)
		msg "$(cat "$TOOL_FILES"/help.txt)\n"
		exit 0;;
	-s)
		SILENT="true"
		shift;;
	-u)
		UPDATE="true"
		shift;;
	-v)
		msg "OpenCore-tool version $VER\n"
		exit 0;;
	-A)
		BUILD_ALL="true"
		shift;;
	-V)
		VERBOSE="-v"
		shift;;

	-X)
		msg "Deleting $BASE_DIR/resources ... "
		rm -rf "$BASE_DIR"/resources
		fin
		REMOVE_ALL="true"
		shift;;
	--)
		shift; break;;
	esac
done

ARG1=$1; ARG2=$2

case $ARG1 in
	b|build) #build first if repo exists, else copy from extras folder
		set_build_type
		;;
	c|copy) #copy from extras first if exists, else build from repo
		msg "\n${YEL}copy mode not implemented yet${NC}\n"
		exit 0
		;;
	d|debug|r|release)
		if [ -n "$BUILD_ALL" ]; then
			if [ -z "$ARG2" ]; then
				BUILD_ALL="then exit"
			fi
			ARG2=$ARG1
			set_build_type
		else
			msg "${YEL}Usage:${NC} must specify ${U}command${NC} or ${B}-A${NC} before $ARG1\n"
			exit 1
		fi
		;;
	u|update)
		check_for_updates
		exit 0
		;;

	*) #fallthrough - check for options with no command or type
		if [ -n "$UPDATE" ]; then # -u option with no following command
			check_for_updates
			exit 0
		fi
		if [ -n "$BUILD_ALL" ]; then # no type given - build DEBUG and RELEASE
			ARG1="debug"
			ARG2="debug"
			set_build_type
			BUILD_ALL="both"
		fi
		if [ -n "$REMOVE_ALL" ]; then #removed resources no command
			exit 0
		fi

		msg "$(cat "$TOOL_FILES"/usage.txt)\n"
#		exit 0
		;;
esac

if [ -n "$UPDATE" ]; then
	check_for_updates
fi

if [ -z "$VERBOSE" ]; then
	exec 6>&1 #start logging
	exec > $LOGFILE
	exec 2>&1
fi

check_requirements

if [ -n "$BUILD_ALL" ];then
	build_all_repos
fi

check_config

init_res_array
add_drivers_res_list
add_kexts_res_list
add_tools_res_list

build_resources

set_up_dest_dir
copy_resources

check_if_Sample_plist_updated

build_vault

if [ -z "$VERBOSE" ];then
	exec 1>&6 6>&- 2>&1 #stop logfile
fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n"

#!/bin/sh -e

INI=$(pwd)
cd -- "$(dirname "$0")"

BASE_DIR=$(pwd)

if [ "$INI" != "$BASE_DIR" ];then # double-click from finder
	FINDER="true"
else
	FINDER=""
fi

UNAME=$(uname)
TOOL_FILES="$BASE_DIR/.tool-files"
GIT_JSON="$TOOL_FILES/git_repo.json"
OUTPUT="$BASE_DIR/OUTPUT"
BUILD_DIR="$OUTPUT/EFI"
LOGFILE="$BASE_DIR/tool.log"
INPUT="$BASE_DIR/INPUT/temp"
CONFIG_PLIST="$INPUT/config.plist"
CONFIG_TXT="$INPUT/config.plist.txt"
DOC_DIR="" # repo doc location

RED='\033[0;31m'; YEL='\033[0;33m'; GRN='\033[0;32m'; BLU='\033[0;34m'
NC='\033[0m'; B='\033[1m'; U='\033[4m'; UO='\033[24m'
INV='\033[7m'
VER="2.1(021219) last checked with OpenCore version DBG-053-2019-11-26"

MODE="prebuiltRelease"; TYPE="debug"  # set default to debug version of prebuilt release

EX_COM=$0' -i'; QUIET=""; VERBOSE=""; CONFIG_CHANGED=""
REMOVE_RES=""; BASE_TOOLS=""; TEXT=""; IGNORE=""

optspec="dhioqrstvVX"

msg() { #write $1 to screen if not quiet
	if [ -z "$QUIET" ]; then
		echo "$1\c" > "$(tty)"
	else
		echo "$1\c"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

missing() {
	msg "\n${RED}ERROR:${NC}\t${B}$1${NC} must be installed to continue\n\t$2\n\t$3\n"
	msg "\tor run '${B}.tool-files/get-deps.sh${NC}' which will get dependencies for you\n"
	exit 1
}

check_requirements() { #required commands moved to .tool-files/requirements for portability
	res=""
	while read -r line
	do
		res="$res*$line"
	done < "$TOOL_FILES/requirements"
	res="$res*"
	res=$(echo "$res"|cut -f 2- -d '*')

	until [ -z "$res" ]
	do
		req=$(echo "$res"|cut -f 1 -d ',')
		reqm1=$(echo "$res"|cut -f 2 -d ',')
		reqm2=$(echo "$res"|cut -f 3 -d ',')
		command -v "$req"||missing "$req" "$reqm1" "$reqm2"
		res=$(echo "$res"|cut -f 2- -d '*')
	done
}

check_config() { #config.plist must exist, even with -i option
	if [ ! -f "$CONFIG_PLIST" ]; then
		msg "\n${RED}ERROR:${NC}\t$CONFIG_PLIST does not exist\n"
		msg "\tEither - copy a config.plist to the INPUT folder,\n"
		msg "\tor - provide a full path to a config.plist './OC-tool path_to_config'\n"
		msg "\tor - pipe a config.plist into OC-tool 'cat some_config_file' | ./OC-tool'\n"
		exit 1
	fi
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR/BOOT"
	mkdir -p "$BUILD_DIR/OC"
	fin
}

clone() { # will only clone if pkg is not local
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		msg "Cloning $1 into $pkg_name ... "
		eval git clone "$1" "$pkg_name"
		fin
	fi
}

check_tool_for_updates() {
	cd "$BASE_DIR"
	msg "\n${GRN}Checking for updates${NC} ... \n"
	msg "OC-tool - " # check OC-tool itself first
	git fetch --all -q
	if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ];then
		git pull $VERBOSE -q
		msg "${GRN}updated${NC}\n\n${YEL}INFO:${NC} OC-tool has been updated, run tool again to continue\n"
		exit 2
	fi
	msg "${GRN}OK${NC}\n"
}

check_resources_for_updates() {
	msg "\n${GRN}Checking existing resources${NC} ... \n"
	res_updated=""
#		find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev|xargs -I {} git -C {} pull $VERBOSE $QUIET
	if [ -d "$RES_DIR" ]; then
		for git_dir in $(find "$RES_DIR" -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev)
		do
			cd "$git_dir"
			git fetch --all -q
			msg "\033[2K\r${git_dir##*/} - "
			if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ]; then
				git pull $VERBOSE -q
				msg "${GRN}updated to ${NC}$(git rev-parse @|cut -c -7)\n"
				res_updated="true"
			else
				msg "${GRN}OK${NC}"
			fi
		done
		msg "\033[2K\rexisting resources "
		if [ -z "$res_updated" ]; then
			msg "are up to date\n"
		else
			msg "have been updated\n"
		fi
	fi
}

curl_failed() { # is this needed?
	msg "\n${RED}ERROR:${NC}\tdownload failed for $res_name\n"
	msg "\tpossible shasum mismatch\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

curl_parent() {
	zip_name="${git_url##*/}"
	zip_dir="$RES_DIR/${res_name%.*}/${zip_name%.*}"
	mkdir -p "$zip_dir"
	cd "$zip_dir"
	if [ ! -e "shasum256" ]; then echo "new" > shasum256; fi
	sha=$(grep "/$res_name/$MODE/$TYPE-sha256 " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$(cat shasum256)" != "$sha" ]; then
		msg "Downloading $zip_name ... "
		curl -L "$git_url" -o "$zip_name"
		shasum -a 256 "$zip_name"|cut -f1 -d ' ' > shasum256
		if [ "$(cat shasum256)" != "$sha" ]; then curl_failed; fi
		msg "unzipping ... "
		if [ "${zip_name##*.}" = "zip" ]; then
			unzip -o "$zip_name"
		fi
		fin
	fi
	srce="$(pwd)"
}

curl_child() { # need parent first, then zip source
	path="$git_url"
	git_url=$(grep "/$parent/$MODE/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')

	temp="$res_name" # hold self
	res_name="$parent"

	curl_parent # temp use parent resources

	git_url="$path"
	res_name="$temp"
	if [ -n "$path" ]; then srce="$srce/$path"; fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
# shellcheck disable=SC1091
	. edksetup.sh
	make -C BaseTools
}

build_failed() { # failed build even after backing up 5 commits
	git checkout master
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

build_shell_tool() { #possible to automate this function?
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/$AUDK_BUILD_DIR/X64"
	if [ -f "$srce/Shell.efi" ]; then return 0; fi
	clone "https://github.com/tianocore/edk2 -b UDK2018 --depth=1" "UDK"
	cd UDK
	msg "Making UDK2018 BaseTools ... "
	make_base_tools; fin

	msg "Patching UDK2018 ... "
	for p in ../Patches/* ; do
		git apply "$p"||echo "$p ignored, does not apply or alread done"
	done; fin

	msg "Building $AUDK_CONFIG Shell.efi (OpenCoreShell.efi) ... "
	build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p ShellPkg/ShellPkg.dsc
	fin
}

build_driver() {
	cd "$RES_DIR"/UDK
	clone "$git_url"
	srce="$(pwd)/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		{ [ ! -e "$srce/$res_name" ] && [ "$res_name" != "base" ]; }; then
		rm -rf "$srce" # extreme, but does force whole pkg build if a piece is missing
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then #no need to build again
				msg "Making base tools ... "
				cd ..
				make_base_tools; fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=1
			while :
			do
				msg "Building $AUDK_CONFIG $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc && break
				if [ "$a" -eq "5" ]; then return 1; fi
				git_sha=$(git rev-parse @|cut -c -7)
				msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
				a=$((a+1))
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

build_kext() {
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	if [ -n "$REMOVE_RES" ];then
		msg "Removing Xcode DerivedData for $pkg_name ... "
		rm -rf "${HOME}"/Library/Developer/Xcode/DerivedData/"${pkg_name}"*
		fin
	fi
	srce="$(pwd)/build/$XCODE_CONFIG"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$res_name" ]; then
		msg "Building $AUDK_CONFIG $pkg_name ... "
		rm -rf Lilu.kext # remove Lilu pkg if it came with repo
		if [ ! -L "Lilu.kext" ]; then #link to acidanthera/Lilu debug version
			ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .
		fi
		if [ ! -L "VirtualSMC.kext" ]; then # AsusSMC needs link to Virtual SMC
			ln -s "$RES_DIR"/Kext_builds/VirtualSMC/build/Debug/VirtualSMC.kext .
		fi
		a=1
		while :
		do
		xcodebuild -config "$XCODE_CONFIG" build && break
			if [ "$a" -eq "5" ]; then return 1; fi
			git_sha=$(git rev-parse @|cut -c -7)
			msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
			git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		done
		if [ "$a" -ne "1" ]; then git checkout master; fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then #copy Products contents back to build level
			cp -r build/Products/* build
		fi
		fin
	fi
}

missing_iasl() {
	msg "${RED}ERROR:${NC}\t${B}iasl${NC} command is required to compile $res_name\n"
	msg "\tEither:\t* install iasl, or\n\t\t* place $res_name in ${B}extras${NC} directory\n"
	exit 1
}

build_acpi() { # compile .dsl into .aml if user hasn't already
	pkg_name=${res_name%%.*}

	srce=$RES_DIR/$(echo "$git_url"|rev|cut -f2- -d/|rev)
	if [ -e "$srce/$res_name" ];then
		return 0
	elif [ -e "$RES_DIR/$git_url" ];then
		command -v iasl||missing_iasl
		msg "Building $res_name ... "
		iasl "$RES_DIR/$git_url"||return 1
		fin
	else
		return 1
	fi
}

get_res() { # extract resource from psuedo array (needed for POSIX)
	eval enabled="\$res$1"
	res_name=${enabled%%,*}; enabled=${enabled#$res_name,}
	git_url=${enabled%%,*}; enabled=${enabled#$git_url,}
	srce=${enabled%%,*}; enabled=${enabled#$srce,}
	dest=${enabled%%,*}; enabled=${enabled#$dest,}
	parent=${enabled%%,*}; enabled=${enabled#$parent,}
}

set_res() { # encode resource into psuedo array (needed for POSIX)
	eval "res$1='$res_name','$git_url','$srce','$dest','$parent','$enabled'"
}

prepare_resources() {
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	if [ "$MODE" = "latestSource" ]; then
		msg "\n${GRN}Building new or updated resources${NC}\n"
		clone "https://github.com/acidanthera/audk" "UDK"

	else
		msg "\n${GRN}Downloading/unzipping needed or updated resources${NC}\n"
	fi

	for G in $(seq 0 4) # cycle first 5 groups
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)") # cycle through members
		do
			get_res "$G$S"
			if [ "$enabled" != "false" ];then
				if [ -z "$srce" ]; then
					case "$MODE" in
						"latestSource")
							case ${res_name##*.} in
							"base"|"efi")
								if [ "$res_name" = "Shell.efi" ]; then #special case
									build_shell_tool||build_failed
								else
									build_driver||build_failed
								fi;;
							"kext")
								if [ "$res_name" = "Lilu.kext" ] && [ "$TYPE" != "debug" ]; then
									set_build_type "debug"
									build_kext||build_failed
									set_build_type "release"
								fi
								build_kext||build_failed;;
							"aml")
								build_acpi||build_failed;;
							esac;;
						"prebuiltRelease")
							case ${res_name##*.} in
							"base")
								;;
							"efi"|"kext"|"aml")
								if [ -n "$parent" ]; then
									curl_child
								else
									curl_parent
								fi;;
							esac;;
					esac
					set_res "$G$S"
				fi
			fi
		done
	done
	msg "\n"
}

res_not_found() {
	if [ -z "$IGNORE" ]; then
		if [ "$MODE" = "latestSource" ]; then
			msg "\n${RED}ERROR:${NC}\t$1 - resource was not found in $GIT_JSON\n"
		else
			msg "\n${RED}ERROR:${NC}\t$1 - no prebuilt found for $1\n"
		fi
		msg "\t$1 file not found in extras directory\n"
		msg "\tEither place $1 in extras directory to build EFI with $1\n"
		msg "\tor run with -i option to build EFI without $1\n"
		msg "\tfor example, try '$EX_COM'\n"
		exit 1
	else
		msg "${YEL}WARNING:${NC} $1 repo not in $GIT_JSON or extras directory - ${YEL}IGNORING${NC}\n"
		IGNORE="yes"
		CONFIG_CHANGED="-i option" # need to write new config before build
	fi
}

copy_failed() {
	msg "\n\n${RED}ERROR:${NC} Copying $res_name to $dest failed, see $LOGFILE for details.\n"
	exit 1
}

copy_resources() {
	msg "\n${GRN}Moving ${YEL}$MODE${GRN} resources into place${NC}\n"
	IGNORE="" # no more ignoring for you
	for G in $(seq 0 4)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			if [ "$enabled" = "true" ];then
				if [ -n "$dest" ]; then
					if [ "$srce" = "unknown" ];then # catch additions from TUI
						res_not_found "$res_name"
					else
						dest_name="$res_name" # workaround for HFSPlus and HfsPlus
						if [ "$dest_name" = "HfsPlus.efi" ]; then res_name="HFSPlus.efi"; fi
						msg "Copying $dest_name to $dest ... "
						mkdir -p "$BUILD_DIR/$dest"
						cp -r "$srce/$res_name" "$BUILD_DIR/$dest/$dest_name"||copy_failed
						fin
					fi
				fi
			fi
		done
	done
}

plist_changed() { # plist from OpenCorePkg has changed, warn user to check their plist
	mkdir -p "$BASE_DIR"/Docs
	cp "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	msg "\n${YEL}NOTE:${NC}\tDocs/Sample.plist has changed from last run.\n"
	msg "\tYou may want to check it for any changes that could apply to\n"
	msg "\t$filePath\n"
}


check_if_Sample_plist_updated() {
	DOC_DIR="$RES_DIR/UDK/OpenCorePkg/Docs"
	if [ -e "$BASE_DIR/Docs/Sample.plist" ]; then
		cmp --silent "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist||plist_changed
	else
		cp "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	fi
}

vault_failed() {
	msg "${RED}ERROR:${NC} vault build failed, see $LOGFILE for details\n"
	exit 1
}

build_vault() {
	msg "\nBuilding vault files for $BUILD_DIR ... "
	if [ ! -e "$RES_DIR/UDK/OcSupportPkg" ]; then
		mkdir -p "$RES_DIR/UDK/OcSupportPkg"
		cd "$RES_DIR/UDK/OcSupportPkg"
		curl -L -O "https://github.com/rusty-bits/OcSupportPkg/releases/download/161119/OcSupportPkg-DEBUG-161119.zip"
		unzip "OcSupportPkg-DEBUG-161119.zip"
	fi
	cd "$BUILD_DIR"/OC
	if ls vault* 1> /dev/null 2>&1; then
		rm vault.*
	fi
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .||return 1
	make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool||return 1
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub||return 1
	str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
	off=$((str+16))
	len=$(wc -c vault.pub|cut -f1 -d 'v'|tr -d ' ')
	dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count="$len" conv=notrunc
	rm vault.pub
	fin
}

find_srce_url() {
	parent=$(grep "/$res_name/parent " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$MODE" = "latestSource" ]; then
		git_url=$(grep "/$res_name/$MODE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		if [ -z "$git_url" ]; then
			git_url=$(grep "/$parent/latestSource " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		fi
	else
		if [ -z "$parent" ]; then
			git_url=$(grep "/$res_name/$MODE/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		else
			git_url=$(grep "/$res_name/path " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		fi
	fi
}

add_res_array() { # add a resource to the psuedo array (neede for POSIX)
	find_srce_url
	if [ "$dest" != "OC/ACPI" ];then
		if [ -n "$git_url" ] || [ -n "$parent" ]; then # found repo
			srce=""
		elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ "$enabled" = "false" ]; then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	else # check extras folder first for ACPI files
		if [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ -n "$git_url" ]; then # found repo
			srce=""
		elif [ "$enabled" = "false" ];then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	fi
	if [ "$IGNORE" = "yes" ]; then
		srce="unknown"
		enabled="ignored"
		IGNORE="true"
	fi
	set_res "$G$S"
}

add_resource() { #add_resource "Group" "Section" "subsec" "Path"
	G=$1
	if [ "$G" -lt "5" ]; then
		num=$(grep -c "^$2|*$3|[0-9]*|string|$4|" "$CONFIG_TXT")
	else
		num=$(grep -c "^$2|$3|" "$CONFIG_TXT")
	fi
	for S in $(seq "0" "$((num-1))")
	do
		case "$G" in
			1|2|4)
				res_name=$(grep "^$2|*$3|$S|string|$4" "$CONFIG_TXT"|cut -f2 -d '"')
				enabled=$(grep "^$2|*$3|$S|bool|Enabled|" "$CONFIG_TXT"|cut -f2 -d '"')
				add_res_array;;
			3)
				res_name=$(grep "^$2|*$3|$S|string|$4" "$CONFIG_TXT"|cut -f2 -d '"')
				enabled="true"
				add_res_array;;
			5|6|7|8)
				res_name=$(grep "^$2|Quirks|$S|" "$CONFIG_TXT"|cut -f8 -d '|')
				enabled=$(grep "|$res_name|" "$CONFIG_TXT"|cut -f2 -d '"')
				set_res "$G$S";;
		esac
	done
	eval G"$G"_NUM="$S"
}

#this is an ugly function, rewrite it if possible
init_res_array() { # base-resources moved into .tool-files for portability
	G=0; S="-1"
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=$line,true"
	done < "$TOOL_FILES/no-pre-base-resources"
	preB=$S
	if [ "$MODE" = "latestSource" ]; then
		for S in $(seq 0 $preB) # add resources without prebuilts
		do
			get_res "0$S"
			if [ "$res_name" = "base" ]; then res_name="$git_url"; fi
			add_res_array
			res_name="base"
			set_res "0$S"
		done
	fi

	while read -r line
	do
		S=$((S+1))
		eval "res0$S=$line,true"
	done < "$TOOL_FILES/pre-base-resources"
	eval G0_NUM=$S
	for S in $(seq $((preB+1)) "$G0_NUM") # add resources with prebuilts
	do
		get_res "0$S"
		add_res_array
	done
	G0_NUM=$((G0_NUM+1))
	eval "res0$G0_NUM=config.plist,,'$INPUT',OC,,true"
}

set_build_type() {
	case $1 in
		d|debug)
			TYPE="debug"; XCODE_CONFIG="Debug";;
		r|release)
			TYPE="release"; XCODE_CONFIG="Release";;
		*)
			msg "need to specify ${U}debug${NC} or ${U}release${NC} after ...\n"
			exit 1;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
}

print_res_array() { # debug aid to list psuedo array
	msg "\033[J\033[0m\n"
	for G in $(seq 0 4)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			msg "$G$S|$res_name|$git_url|$srce|$dest|$parent|$enabled\n"
		done
	done
}

write_new_array() { # write array section changes to new plist
	while [ "$line" != "</array>" ]
	do
		get_res "$G$S"
		while [ "$line" != "</dict>" ]
		do
			read -r line
			echo "$line" >> "$OUT"
	#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
			if [ "$line" = "<key>Enabled</key>" ];then
				read -r line
				if [ "$enabled" = "ignored" ]; then
					echo "<false/>" >> "$OUT" # ignored resource
				else
					echo "<$enabled/>" >> "$OUT"
				fi
			fi
		done
		S=$((S+1))
		read -r line
		echo "$line" >> "$OUT"
	done
}

write_new_drivers() { # write driver section changes to new plist
	while [ "$line" != "<key>Drivers</key>" ]
	do
		read -r line
		echo "$line" >> "$OUT"
	done
	get_res "$G$S"
	while [ "$line" != "</array>" ]
	do
		read -r line
		if [ "$line" = "<string>$res_name</string>" ];then
			if [ "$enabled" = "true" ];then
				echo "$line" >> "$OUT"
			fi
			S=$((S+1))
			get_res "$G$S"
		else
			echo "$line" >> "$OUT"
		fi
	done
}

write_new_quirks() { # write quirks section changes to new plist
	get_res "$G$S"
	while [ "$line" != "<key>Quirks</key>" ];
	do
		read -r line
		echo "$line" >> "$OUT"
	done
	while [ "$line" != "</dict>" ]
	do
#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
		if [ "$line" = "<key>$res_name</key>" ];then
			read -r line
			case "$enabled" in
				true|false)
					echo "<$enabled/>" >> "$OUT";;
				ignored) # ignored resources
					echo "<false/>" >> "$OUT";;
				[0-9])
					echo "<integer>$enabled</integer>" >> "$OUT";;
				*)
					echo "$line" >> "$OUT";;
			esac
			S=$((S+1))
			get_res "$G$S"
		fi
		read -r line
		echo "$line" >> "$OUT"
	done
}

write_new_conf() { # write new config.plist based on changes in psuedo array
	OUT=$BASE_DIR/Docs/config.plist
	msg "\033[J\nWriting new config.plist to $OUT ... "
	rm -rf "$OUT"
	while read -r line
	do
		echo "$line" >> "$OUT"
#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
		case "$line" in
			"<key>ACPI</key>")
				G=1; S=0;
				write_new_array
				G=5; S=0;
				write_new_quirks;;
			"<key>Kernel</key>")
				G=2; S=0;
				write_new_array
				G=6; S=0;
				write_new_quirks;;
			"<key>UEFI</key>")
				G=3; S=0;
				write_new_drivers
				G=7; S=0;
				write_new_quirks;;
			"<key>Tools</key>")
				G=4; S=0;
				write_new_array;;
			"<key>Booter</key>")
				G=8; S=0;
				write_new_quirks;;
			"<key>RequireVault</key>"|"<key>RequireSignature</key>")
				read -r line
				echo "<$USE_VAULT/>" >> "$OUT";;
		esac
	done < "$CONFIG_PLIST"
	fin
}

set_ROW_COL(){ # set ROW and COL for TUI mode based on group and section
	case "$G" in
		1|2|3|4)
			ROW=$((S+3))
			COL=$(((G-1)*C+1));;
		5|6|7|8)
			ROW=$((S+BOT+5))
			COL=$(((G-5)*C+1));;
		9)
			ROW=2
			COL=$(((S-1)*C+1));;
	esac
}

set_text_header() {
	eval res91="\\${U}A\\${UO}CPI/\\${U}Q\\${UO}uirks,"
	eval res92="\\${U}K\\${UO}exts/K\\${U}e\\${UO}rnel,"
	eval res93="\\${U}D\\${UO}rivers/\\${U}U\\${UO}EFI,"
	eval res94="\\${U}T\\${UO}ools/\\${U}B\\${UO}ooter,"
	eval G9_NUM="4"
}

set_color() { # set TUI section color based on resource
	case "$enabled" in
		true)
			color="$GRN"; MSG="+";;
		false)
			color="$RED"; MSG="-";;
		ignored)
			color="$YEL"; MSG="-i";;
		*)
			color="$BLU"; MSG="$enabled";;
	esac
	if [ "$G" = "9" ];then color="$NC";fi
}

select_MSG() { # draw highligted resource in TUI
	msg "\033[${ROW};${COL}H$color$INV $res_name $MSG \033[0m"
}

unselect_MSG() { # clear highlighted resource in TUI
	msg "\033[${ROW};${COL}H$color $res_name $MSG "
	MSG=""
}

draw_key() {
	if [ "$R" -gt "30" ];then
		msg "$NC\033[$((BOT+KEY+5))H\n"
		msg "$(cat "$TOOL_FILES/key.msg")\n"
	fi
}

draw_header() {
	if [ "$TYPE" = "debug" ]; then
		inc_syms="${GRN}include${NC}"
	else
		inc_syms="${RED}no${NC}"
	fi
	msg "$NC\033[Hmode=$GRN$MODE$NC ${U}d${NC}ebugSyms=${inc_syms} RequireVault="
	if [ "$USE_VAULT" = "true" ];then
		msg "$GRN"
	else
		msg "$RED"
	fi
	msg "$INV$USE_VAULT$NC\033[K INPUT=${GRN}$filePath${NC}  "
	OLD_G=$G; OLD_S=$S
	G=9; color=${NC}
	for S in $(seq 1 4)
	do
		get_res "$G$S"
		set_ROW_COL
		unselect_MSG
	done
	G=$OLD_G; S=$OLD_S
}

redraw_screen() {
	OLD_G=$G; OLD_S=$S
	if [ "$G" -lt "5" ];then
		draw_screen
	else
		for S in $(seq $((OLD_S)) "$KEY"); do
			msg "\033[$((ROW+1))H\033[2K"
			for G in $(seq 5 8); do
				get_res "$G$S"
				set_ROW_COL
				set_color
				unselect_MSG
			done
		done
	fi
	msg "\033[J"
	draw_key
	draw_footer
	G=$OLD_G; S=$OLD_S
}


draw_screen() {
	R=$(stty size|cut -f1 -d ' '); C=$(stty size|cut -f2 -d ' ')
	C=$((C/4))
	msg "\033[2J\033[H"
	draw_header
	for G in $(seq 1 8)
	do
#		len="$(eval echo \$G"$G"_NUM)"
		eval len="\$G${G}_NUM"
		if [ "$G" -le "4" ];then # BOT = longest group of 1 - 4
			if [ "$BOT" -lt "$len" ];then BOT="$len";fi
		else # KEY = longest group of 5 - 7
			if [ "$KEY" -lt "$len" ]; then KEY="$len";fi
		fi
		for S in $(seq 0 "$len")
		do
			get_res "$G$S"
			set_ROW_COL
			set_color
			unselect_MSG
		done
	done
	draw_key
	draw_footer
}

draw_footer() {
	msg "\033[$((R-1));2H$GRN$INV enabled $NC $RED$INV disabled $NC "
	msg "$YEL$INV ignored $NC $BLU$INV numeric $NC  q - to quit   r - redraw screen"
}

get_CHAR() {
	stty -icanon
	CHAR=$(dd bs=1 count=1 2>/dev/null|od -A n -a|tr -d ' ')
	stty icanon
}

text_user_interface() {
	git_url=""; srce=""; dest=""; parent=""
	add_resource "5" "ACPI" "Quirks"; add_resource "6" "Kernel" "Quirks"
	add_resource "7" "UEFI" "Quirks"; add_resource "8" "Booter" "Quirks"
	BOT=0; KEY=0
	CHAR=""
	set_text_header
	msg "$(tput smcup)"
	stty -echo
	draw_screen
	G=1; S=0; get_res "$G$S"
	set_ROW_COL; set_color
	select_MSG
	while [ "$CHAR" != "g" ]
	do
		get_CHAR
		unselect_MSG
		case $CHAR in
			b)
#				S=$(eval echo \$G"$G"_NUM);;
				eval S="\$G${G}_NUM";;
			d)
				if [ "$TYPE" = "release" ];then
					TYPE="debug"
				else
					TYPE="release"
				fi
				draw_header;;
			e) # jump to kExt quirks
				G=6; S=0;;
			i)
				DESC=""
				while read -r line
				do
					read -r desc
					if [ "$line" = "$res_name" ];then
						DESC=$desc
						break
					fi
				done < "$TOOL_FILES/description.txt"
				if [ -z "$DESC" ];then DESC="No description found.";fi
				msg "$NC\033[2K\n$DESC\033[K\n\033[2K"
				select_MSG
				get_CHAR
				if [ "$CHAR" = "esc" ];then esc="true"; fi
				redraw_screen;;
			p) # debug dump array
				stty echo
				msg "${NC}"
				msg "$(tput rmcup)"
				print_res_array
				exit 0;;
			q)
				stty echo
				CHAR='g'
				TEXT="quit";;
			r)
				OLD_G=$G; OLD_S=$S
				draw_screen
				G=$OLD_G; S=$OLD_S;;
			s) # exit loop with 'g' then save Docs/config.plist if changed then stop
				CHAR='g'
				TEXT='stop';;
			v) # toggle USE_VAULT
				if [ "$USE_VAULT" = "true" ];then
					USE_VAULT="false"
				else
					USE_VAULT="true"
				fi
				draw_header
				CONFIG_CHANGED="-t option";;
			sp|nl) # only mark CONFIG_CHANGED if change was done
				case "$enabled" in
					true)
						enabled="false";;
					false)
						enabled="true";;
				esac
				CONFIG_CHANGED="-t option"
				set_res "$G$S";;
			A|k) # move up
				if [ -n "$esc" ] || [ "$CHAR" = "k" ]; then
					S=$((S-1))
					if [ "$S" -lt "0" ];then
						if [ "$G" -gt "4" ];then
							G=$((G-4))
#							S="$(eval echo \$G"$G"_NUM)"
							eval S="\$G${G}_NUM"
						else
							S=0
						fi
					fi
				else # jump to ACPI group
					G=1; S=0
				fi
				esc="";;
			B|j) # move down
				if [ -n "$esc" ] || [ "$CHAR" = "j" ]; then
					S=$((S+1))
#					len="$(eval echo \$G"$G"_NUM)"
					eval len="\$G${G}_NUM"
					if [ "$S" -gt "$len" ];then
						if [ "$G" -lt "5" ];then
							G=$((G+4))
							S=0
						else
							S=$len
						fi
					fi
				else # jump to Booter quirks
					G=8; S=0
				fi
				esc="";;
			C|l) # move right
				G=$((G+1))
				if [ "$G" -eq "5" ];then G=4;fi
				if [ "$G" -eq "9" ];then G=8;fi
				esc="";;
			D|h) # move left
				if [ -n "$esc" ] || [ "$CHAR" = "h" ]; then
					G=$((G-1))
					if [ "$G" -eq "0" ];then G=1;fi
					if [ "$G" -eq "4" ];then G=5;fi
					esc=""
				else
					G=3; S=0
				fi;;
			K) # jump to kext group
				G=2; S=0;;
			T) # jump to Tools group
				G=4; S=0;;
			U) # jump to UEFI quirke
				G=7; S=0;;
			Q) # jump to ACPI quirks
				G=5; S=0;;
			esc|'[')
				esc="true";;
		esac
		if [ "$S" -gt "$(eval echo \$G"$G"_NUM)" ];then
#			S=$(eval echo \$G"$G"_NUM)
			eval S="\$G${G}_NUM"
		fi
		if [ "$S" -lt "0" ];then S=0; fi
		get_res "$G$S"
		set_ROW_COL
		set_color
		select_MSG
	done
	stty echo
	msg "${NC}"
}

start_logging() {
	if [ -z "$VERBOSE" ]; then
		exec 6>&1 #start logging
		exec > "$LOGFILE"
		exec 2>&1
	fi
}

stop_logging() {
	if [ -z "$VERBOSE" ];then
		exec 1>&6 6>&- 2>&1 #stop logfile
	fi
}

remove_resource_msg() {
	msg "\n ${RED}***${NC} WARNING: -X option used ${RED}****************************************\n"
	msg " ${RED}*** ${NC}$RES_DIR has been removed\n"
	msg " ${RED}*** ${NC}the -X option is only useful if there is an issue with the\n"
	msg " ${RED}*** ${NC}previously downloaded resources causing problems while building.\n"
	msg " ${RED}*** ${NC}Using it at any other time will only increase bandwith usage and\n"
	msg " ${RED}*** ${NC}compile time, in many cases requiring all tools to be rebuilt.\n"
	msg " ${RED}*********************************************************************${NC}\n"
}

#****** Start build ***************
while getopts "$optspec" optchar; do
case "${optchar}" in
		d)
			MODE="prebuiltDaily"
			EX_COM="${EX_COM}d"
			msg "\n${YEL}$MODE${NC} not implemented yet.\n"
			exit 1;;
		h) # help
			msg "$(cat "$TOOL_FILES"/help.msg)\n"
			exit 0;;
		i)
			IGNORE="true";;
		o)
			FINDER="open"
			EX_COM="${EX_COM}o";;
		q)
			QUIET="-q"
			EX_COM="${EX_COM}q";;
		r)
			TYPE="release"
			EX_COM="${EX_COM}r";;
		s)
			MODE="latestSource"
			EX_COM="${EX_COM}s";;
		v)
			VERBOSE="-v"
			EX_COM="${EX_COM}v";;
		t)
			TEXT="true"
			EX_COM="${EX_COM}t";;
		V)
			msg "OC-tool version $VER\n"
			exit 0;;
		X)
			REMOVE_RES="true";;
		*)
			msg "$(cat "$TOOL_FILES/usage.msg")\n"
			exit 1;;
	esac
done
eval filePath="\$$OPTIND"

start_logging

RES_DIR="$BASE_DIR/resources/$MODE"

if [ -p /dev/stdin ]; then # data was piped
	mkdir -p "$INPUT"
	cat > "$CONFIG_PLIST"
	QUIET="-q" # currently stdin is not a terminal, no output to tty
	TEXT="" # no TUI use either with piped config.plist
	filePath="stdin"
else  #  no input found on stdin
	if [ -e "$filePath" ]; then
		EX_COM="${EX_COM} ${filePath}"
	else
		if [ -n "${filePath}" ]; then
			msg "config.plist file '${filePath}' not found\n"
			msg "$(cat "$TOOL_FILES"/usage.msg)\n"
			exit 1
		else
			filePath="$BASE_DIR/INPUT/config.plist"
		fi
	fi
	mkdir -p "$INPUT"
	cp "${filePath}" "$CONFIG_PLIST"
fi
cd "$INPUT"
"$TOOL_FILES/parsePlist.sh" > "$CONFIG_TXT"

if [ "$MODE" != "latestSource" ] && [ "$UNAME" = "Darwin" ]; then # show start messaged
	msg "To build from source use ${B}-s${NC} option\n"
fi
msg "For help use '${B}./OC-tool -h${NC}'\n\nUsing ${filePath}\n"

check_tool_for_updates

if [ -n "$REMOVE_RES" ]; then rm -rf "$RES_DIR"; fi

set_build_type "$TYPE"

if [ "$MODE" = "latestSource" ]; then check_resources_for_updates; fi

if [ -n "$REMOVE_RES" ]; then remove_resource_msg; fi #show warning in tool.log also
if [ "$MODE" = "latestSource" ]; then check_requirements; fi

check_config

#cd "$TOOL_FILES"
#./parse_json.sh < git_repo.json > git_repo.json.txt

init_res_array
dest="OC/ACPI"; add_resource "1" "ACPI" "Add" "Path"
dest="OC/Kexts"; add_resource "2" "Kernel" "Add" "BundlePath"
dest="OC/Drivers"; add_resource "3" "UEFI" "Drivers"
dest="OC/Tools"; add_resource "4" "Misc" "Tools" "Path"

USE_VAULT=$(grep "|bool|RequireVault|" "$CONFIG_TXT"|cut -f2 -d '"')

if [ -n "$TEXT" ] && [ -z "$QUIET" ]; then
	msg "\nSwitching to TUI ... "
	text_user_interface
	msg "\033[J\n" # cleanup for TERM types that don't buffer
	msg "$(tput rmcup)"
	msg "${GRN}done in TUI${NC}\n"
fi

if [ "$TEXT" = "quit" ];then exit 0;fi # quit without saving changes

if [ "$MODE" != "latestSource" ] && [ "$UNAME" != "Darwin" ]; then
	if [ "$USE_VAULT" = "true" ]; then
		USE_VAULT="false"
		CONFIG_CHANGED="temp vault disable"
		msg "\n${YEL}NOTICE:${NC}\tcurrently unable to build vault files on $UNAME\n"
		msg "\tvault disabled for prebuilts not made on macOS\n"
	fi
fi

if [ -n "$CONFIG_CHANGED" ]; then
	write_new_conf
	command -v "plutil"&&plutil -convert xml1 "$BASE_DIR/Docs/config.plist"
	get_res "0$G0_NUM" # update location for config.plist file
	srce="$BASE_DIR/Docs"
	set_res "0$G0_NUM"
fi

if [ "$TEXT" = "stop" ];then exit 0;fi # save and quit

prepare_resources
set_up_dest_dir
copy_resources

if [ "$MODE" = "latestSource" ];then check_if_Sample_plist_updated; fi

if [ "$USE_VAULT" = "true" ];then
	build_vault||vault_failed
fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n\n"
if [ -n "$CONFIG_CHANGED" ]; then
	msg "${YEL}NOTE:${NC}\tconfig.plist in $BUILD_DIR ${YEL}was changed${NC} by $CONFIG_CHANGED\n"
	msg "\tthis has been done to ensure OC wont fail on boot with this new EFI folder\n"
	msg "\tthe modified config.plist has also been placed in $BASE_DIR/Docs\n"
	msg "\tthe original $filePath ${YEL}has not been touched${NC}\n\n"
fi

stop_logging

if [ -n "$FINDER" ] && [ "$UNAME" = "Darwin" ];then open "$OUTPUT"; fi # open to EFI if -o or dbl-click

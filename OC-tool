#!/bin/sh -e

# testing shellcheck disable=SC2034

INI=$(pwd)
cd -- "$(dirname "$0")"

BASE_DIR=$(pwd)

if [ "$INI" != "$BASE_DIR" ];then # double-click from finder
	FINDER="true"
else
	FINDER=""
fi

TTY_OUT=$(tty)
UNAME=$(uname)
TOOL_FILES="$BASE_DIR/.tool-files"
GIT_JSON="$TOOL_FILES/git_repo.json"
OUTPUT="$BASE_DIR/OUTPUT"
BUILD_DIR="$OUTPUT/EFI"
LOGFILE="$BASE_DIR/tool.log"
INPUT="$BASE_DIR/INPUT/temp"
CONFIG_PLIST="$INPUT/config.plist"
CONFIG_TXT="$INPUT/config.plist.txt"
DOC_DIR="" # repo doc location
HAS_UNZIP=""
SHELL_EFI="Shell_EA4BB293-2D7F-4456-A681-1F22F42CD0BC.efi"

RED='\033[0;31m'; YEL='\033[0;33m'; GRN='\033[0;32m'; BLU='\033[0;34m'
NC='\033[0m'; B='\033[1m'; U='\033[4m'; UO='\033[24m'
INV='\033[7m'
VER="2.6(150120) last checked with OpenCore version DBG-054-2020-01-11"

MODE="prebuiltRelease"; TYPE="debug"  # set default to debug version of prebuilt release

EX_COM=$0' -i'; QUIET=""; VERBOSE=""; CONFIG_CHANGED=""
REMOVE_RES=""; BASE_TOOLS=""; TEXT=""; IGNORE=""; UPDATE=""
IGNORE_BOOL=""; USE_VAULT=""; USE_SIG=""

G10_NUM="0"; edit_res_num="-1"; lone=""
DEBUG=""
optspec="dhinoqrstvDVX"

msg() { #write $1 to screen if not quiet
	if [ -z "$QUIET" ]; then
		printf "%b" "$1" > "$TTY_OUT"
	else
		printf "%b" "$1"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

missing() {
	msg "\n${RED}ERROR:${NC}\t${B}$1${NC} must be installed to continue\n\t$2\n\t$3\n"
	msg "\tor run '${B}.tool-files/get-deps.sh${NC}' which will get dependencies for you\n"
	exit 1
}

check_requirements() { #required commands moved to .tool-files/requirements for portability
	res=""
	while read -r line
	do
		res="$res*$line"
	done < "$TOOL_FILES/requirements"
	res="$res*"
	res=$(echo "$res"|cut -f 2- -d '*')

	until [ -z "$res" ]
	do
		req=$(echo "$res"|cut -f 1 -d ',')
		reqm1=$(echo "$res"|cut -f 2 -d ',')
		reqm2=$(echo "$res"|cut -f 3 -d ',')
		command -v "$req"||missing "$req" "$reqm1" "$reqm2"
		res=$(echo "$res"|cut -f 2- -d '*')
	done
}

check_config() { #config.plist must exist, even with -i option
	if [ ! -f "$BASE_DIR/INPUT/config.plist" ]; then
		msg "\n${RED}ERROR:${NC}\t$BASE_DIR/INPUT/config.plist does not exist\n"
		msg "\tEither - copy a config.plist to the INPUT folder,\n"
		msg "\tor - provide a full path to a config.plist './OC-tool path_to_config'\n"
		msg "\tor - pipe a config.plist into OC-tool 'cat some_config_file' | ./OC-tool'\n"
		exit 1
	fi
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR/BOOT"
	mkdir -p "$BUILD_DIR/OC"
	fin
}

update_log() {
	new_hash=$(git rev-parse @|cut -c -7)
	echo "$(date) $1 $2 - $new_hash" >> "$BASE_DIR/update.log"
}

clone() { # will only clone if pkg is not local
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		if [ -z "$UPDATE" ]; then
			msg "Cloning $1 into $pkg_name ... "
			eval git clone "$1" "$pkg_name"
			fin
			cd "$pkg_name"
			update_log "Cloned" "$pkg_name"
			cd ..
		else
			msg "\nCan't clone $pkg_name while using -n option.\n"
			exit 0
		fi
	fi
}

check_tool_for_updates() {
	cd "$BASE_DIR"
	msg "\n${GRN}Checking for updates${NC} ... \n"
	msg "OC-tool - " # check OC-tool itself first
	git fetch --all -q
	if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ];then
		git pull $VERBOSE -q
		msg "${GRN}updated${NC}\n\n${YEL}INFO:${NC} OC-tool has been updated, run tool again to continue\n"
		update_log "Updated" "OC-tool"
		exit 2
	fi
	msg "${GRN}OK${NC}\n"
}

check_lilu_for_updates() {
	msg "\n${GRN}Checking Lilu${NC} ... "
	if [ -d "$RES_DIR/Kext_builds/Lilu" ]; then
		cd "$RES_DIR/Kext_builds/Lilu"
		git fetch --all -q
		if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ]; then
			new_hash=$(git rev-parse @|cut -c -7)
			msg "\n${GRN}Lilu updated to ${NC}$new_hash\n"
			echo "$(date) Updated Lilu - $new_hash" >> "$BASE_DIR/update.log"
			msg "${YEL}All kexts will be rebuilt${NC}\n"
			rm -rf "$RES_DIR/Kext_builds"
		else
			fin
		fi
	else
		msg "\n${YEL}no existing Lilu found${NC}\n"
		msg "Any existing kexts will be rebuilt to insure they are current\n"
		rm -rf "$RES_DIR/Kext_builds"
	fi
}

check_resources_for_updates() {
#		find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev|xargs -I {} git -C {} pull $VERBOSE $QUIET
	res_updated=""
	msg "\n${GRN}Checking other existing resources${NC} ... \n"
	if [ -d "$RES_DIR" ]; then
		for git_dir in $(find "$RES_DIR" -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev)
		do
			cd "$git_dir"
			git fetch --all -q
			msg "\033[2K\r${git_dir##*/} - "
			if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ]; then
				git pull $VERBOSE -q
				new_hash=$(git rev-parse @|cut -c -7)
				msg "${GRN}updated to ${NC}$new_hash\n"
				echo "$(date) Updated ${git_dir##*/} - $new_hash" >> "$BASE_DIR/update.log"
				res_updated="true"
			else
				msg "${GRN}OK${NC}"
			fi
		done
		msg "\033[2K\rexisting resources "
		if [ -z "$res_updated" ]; then
			msg "are up to date\n"
		else
			msg "have been updated\n"
		fi
	fi
}

curl_failed() { # is this needed?
	msg "\n${RED}ERROR:${NC}\tdownload failed for $res_name\n"
	msg "\tpossible shasum mismatch\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

unzip_failed() {
	msg "\n${RED}ERROR:$NC\tfailed to unzip $zip_name\n"
	msg "\t${YEL}unzip${NC} command was not found, tried using ${YEL}tar${NC} command\n"
	msg "\twhich is able to unzip on some systems, but apparently not this one\n"
	msg "\t${YEL}unzip${NC} command will need to be installed to continue\n"
	msg "\tand you may need to use the X option at first to clear out unzipped files\n"
	exit 1
}

curl_parent() {
	zip_name="${git_url##*/}"
	zip_dir="$RES_DIR/${res_name%.*}/${zip_name%.*}"
	mkdir -p "$zip_dir"
	cd "$zip_dir"
	if [ ! -e "shasum256" ]; then echo "new" > shasum256; fi
	sha=$(grep "/$res_name/$MODE/@0/$TYPE-sha256 " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$(cat shasum256)" != "$sha" ]; then
		if [ -z "$UPDATE" ]; then
			msg "Downloading $zip_name ... "
			curl -L "$git_url" -o "$zip_name"
			if [ -z "$HAS_SHASUM" ]; then
				shasum -a 256 "$zip_name"|cut -f1 -d ' ' > shasum256
				if [ "$(cat shasum256)" != "$sha" ]; then curl_failed; fi
			fi
			msg "unzipping ... "
			command -v unzip||HAS_UNZIP="false"
			if [ "${zip_name##*.}" = "zip" ]; then
				if [ -z "$HAS_UNZIP" ]; then
					unzip -o "$zip_name"
				else
					tar -xvf "$zip_name"||unzip_failed
				fi
			fi
			fin
			echo "$(date) Downloaded $zip_name - $(printf "%b" "$sha"|cut -c -7)" >> "$BASE_DIR/update.log"
		else
			msg "\nCan't download $zip_name while using -n option.\n"
			exit 0
		fi
	fi
	srce="$(pwd)"
}

curl_child() { # need parent first, then zip source
	path="$git_url"
	git_url=$(grep "/$parent/$MODE/@0/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')

	temp="$res_name" # hold self
	res_name="$parent"

	curl_parent # temp use parent resources

	git_url="$path"
	res_name="$temp"
	if [ -n "$path" ]; then srce="$srce/$path"; fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
# shellcheck disable=SC1091
	. edksetup.sh
	make -C BaseTools
}

build_failed() { # failed build even after backing up 5 commits
	git checkout master
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

build_shell_tool() { #possible to automate this function?
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/$AUDK_BUILD_DIR/X64"
#	if [ -f "$srce/$SHELL_EFI" ]; then return 0; fi
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$SHELL_EFI" ]; then
		rm -rf "$srce"
		clone "https://github.com/acidanthera/audk -b master --depth=1" "UDK"
		cd UDK
		msg "Making audk BaseTools for Shell.efi ... "
		make_base_tools; fin

		msg "Patching audk for Shell.efi ... "
		for p in ../Patches/* ; do
			git apply "$p"||echo "$p ignored, does not apply or alread done"
		done; fin

		msg "Building $AUDK_CONFIG Shell.efi ($SHELL_EFI) ... "
		build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p ShellPkg/ShellPkg.dsc
		fin
		cd ..
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		BASE_TOOLS="" # insure other drivers use non-patched UDK
	fi
}

build_driver() {
	cd "$RES_DIR/UDK"
	clone "$git_url"
	srce="$(pwd)/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		{ [ ! -e "$srce/$res_name" ] && [ "$res_name" != "base" ]; }; then
		rm -rf "$srce" # extreme, but does force whole pkg build if a piece is missing
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then #tools not built yet
				msg "Making base tools ... "
				cd ..
				make_base_tools; fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=1
			while :
			do
				msg "Building $AUDK_CONFIG $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc && break
				if [ "$a" -eq "5" ]; then return 1; fi
				git_sha=$(git rev-parse @|cut -c -7)
				msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
				a=$((a+1))
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

build_kext() {
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	if [ -n "$REMOVE_RES" ];then
		msg "Removing Xcode DerivedData for $pkg_name ... "
		rm -rf "${HOME}"/Library/Developer/Xcode/DerivedData/"${pkg_name}"*
		fin
	fi
	srce="$(pwd)/build/$XCODE_CONFIG"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$res_name" ]; then
		msg "Building $AUDK_CONFIG $pkg_name ... "
		rm -rf Lilu.kext # remove Lilu pkg if it came with repo
		if [ ! -L "Lilu.kext" ]; then #link to acidanthera/Lilu debug version
			ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .
		fi
		if [ ! -L "VirtualSMC.kext" ] && [ "$pkg_name" = "AsusSMC" ]; then # AsusSMC needs link to Virtual SMC
			ln -s "$RES_DIR"/Kext_builds/VirtualSMC/build/Debug/VirtualSMC.kext .
		fi
		buildScheme=$(grep "/$res_name/buildScheme " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		a=1
		while :
		do
			if [ -z "$buildScheme" ]; then
				xcodebuild -config "$XCODE_CONFIG" build && break
			else
				xcodebuild -config "$XCODE_CONFIG" -scheme "$buildScheme" -sdk macosx build && break
			fi
			if [ "$a" -eq "5" ]; then return 1; fi
			git_sha=$(git rev-parse @|cut -c -7)
			msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
			git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		done
		if [ "$a" -ne "1" ]; then git checkout master; fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then #copy Products contents back to build level
			cp -r build/Products/* build
		fi
		fin
	fi
}

missing_iasl() {
	msg "${RED}ERROR:${NC}\t${B}iasl${NC} command is required to compile $res_name\n"
	msg "\tEither:\t* install iasl, or\n\t\t* place $res_name in ${B}extras${NC} directory\n"
	exit 1
}

build_acpi() { # compile .dsl into .aml if user hasn't already
	pkg_name=${res_name%%.*}

	srce=$RES_DIR/$(echo "$git_url"|rev|cut -f2- -d/|rev)
	if [ -e "$srce/$res_name" ];then
		return 0
	elif [ -e "$RES_DIR/$git_url" ];then
		command -v iasl||missing_iasl
		msg "Building $res_name ... "
		iasl "$RES_DIR/$git_url"||return 1
		fin
	else
		return 1
	fi
}

get_res() { # extract resource from psuedo array (needed for POSIX)
	eval enabled="\$res$1"
	res_name=${enabled%%|*}; enabled=${enabled#*|}
	git_url=${enabled%%|*}; enabled=${enabled#*|}
	srce=${enabled%%|*}; enabled=${enabled#*|}
	dest=${enabled%%|*}; enabled=${enabled#*|}
	parent=${enabled%%|*}; enabled=${enabled#*|}
}

set_res() { # encode resource into psuedo array (needed for POSIX)
	eval "res$1='$res_name'\|'$git_url'\|'$srce'\|'$dest'\|'$parent'\|'$enabled'"
}

prepare_resources() {
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	if [ "$MODE" = "latestSource" ]; then
		msg "\n${GRN}Building new or updated resources${NC}\n"
		clone "https://github.com/acidanthera/audk" "UDK"

	else
		HAS_SHASUM=""
		msg "\n${GRN}Downloading/unzipping needed or updated resources${NC}\n"
		command -v shasum||HAS_SHASUM="false"
		if [ -n "$HAS_SHASUM" ]; then
			msg "\n${YEL}NOTICE:${NC}\tshasum command is not available\n"
			msg "\tDownloading will continue, but there is no way to check zip file sums\n"
			msg "\tinstall the shasum command if this is an issue\n\n"
		fi
	fi

	for G in $(seq 0 4) # cycle first 5 groups
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)") # cycle through members
		do
			get_res "$G$S"
			if [ "$enabled" != "false" ]; then
				if [ -z "$srce" ]; then
					case "$MODE" in
						"latestSource")
							case ${res_name##*.} in
							"base"|"efi")
								if [ "$res_name" = "Shell.efi" ]; then #special case
									build_shell_tool||build_failed
								else
									build_driver||build_failed
								fi;;
							"kext")
								if [ "$res_name" = "Lilu.kext" ] && [ "$TYPE" != "debug" ]; then
									set_build_type "debug"
									build_kext||build_failed
									set_build_type "release"
								fi
								build_kext||build_failed;;
							"aml")
								build_acpi||build_failed;;
							esac;;
						"prebuiltRelease")
							case ${res_name##*.} in
							"base")
								;;
							"efi"|"kext"|"aml")
								if [ -n "$parent" ]; then
									curl_child
								else
									curl_parent
								fi;;
							esac;;
					esac
					set_res "$G$S"
				fi
			fi
		done
	done
	msg "\n"
}

res_not_found() {
	if [ -z "$IGNORE" ]; then
		if [ "$MODE" = "latestSource" ]; then
			msg "\n${RED}ERROR:${NC}\t$1 - resource was not found in $GIT_JSON\n"
		else
			msg "\n${RED}ERROR:${NC}\t$1 - no prebuilt found for $1\n"
		fi
		msg "\t$1 file not found in extras directory\n"
		msg "\tEither place $1 in extras directory to build EFI with $1\n"
		msg "\tor run with -i option to build EFI without $1\n"
		msg "\tfor example, try '$EX_COM'\n"
		exit 1
	else
		msg "${YEL}WARNING:${NC} $1 repo not in $GIT_JSON or extras directory - ${YEL}IGNORING${NC}\n"
		IGNORE="yes"
		CONFIG_CHANGED="-i option" # need to write new config before build
	fi
}

copy_failed() {
	msg "\n\n${RED}ERROR:${NC} Copying $res_name to $dest failed, see $LOGFILE for details.\n"
	exit 1
}

copy_resources() {
	msg "\n${GRN}Moving ${YEL}$MODE${GRN} resources into place${NC}\n"
	IGNORE="" # no more ignoring for you
	for G in $(seq 0 4)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			if [ "$G" -gt "0" ]; then
				get_edit_res "$enabled"
				enabled="false"
				if [ "$en" = "+" ]; then enabled="true"; fi
#				if [ "$G" -eq "3" ]; then enabled="true"; fi
			fi
			if [ "$enabled" = "true" ];then
				if [ -n "$dest" ]; then
					if [ "$srce" = "unknown" ];then # catch additions from TUI
						res_not_found "$res_name"
					else
						dest_name="$res_name" # workaround for HFSPlus and HfsPlus
						if [ "$dest_name" = "HfsPlus.efi" ]; then res_name="HFSPlus.efi"; fi
						if [ "$dest_name" = "Shell.efi" ] && [ "$MODE" = "latestSource" ]; then res_name="$SHELL_EFI" ;fi
						msg "Copying $dest_name to $dest ... "
						mkdir -p "$BUILD_DIR/$dest"
						cp -r "$srce/$res_name" "$BUILD_DIR/$dest/$dest_name"||copy_failed
						fin
					fi
				fi
			fi
		done
	done
}

plist_changed() { # plist from OpenCorePkg has changed, warn user to check their plist
	diff -u "$BASE_DIR/Docs/Sample.plist" "$DOC_DIR/Sample.plist" > "$BASE_DIR/Docs/diff_Sample.txt"||true
	cp "$DOC_DIR/Sample.plist" "$BASE_DIR/Docs/Sample.plist"
	msg "\n${YEL}NOTE:${NC}\tDocs/Sample.plist has changed from last run.\n"
	msg "\tdiffs have been placed in $BASE_DIR/Docs/diff_Sample.plist\n"
	msg "\tyou can see the differences with 'cat ./Docs/diff_Sample.txt'\n"
	msg "\t${YEL}You may want to check for any changes${NC} that could apply to\n"
	msg "\t$filePath\n"
}


check_if_Sample_plist_updated() {
	DOC_DIR="$RES_DIR/UDK/OpenCorePkg/Docs"
	if [ -e "$BASE_DIR/Docs/Sample.plist" ]; then
		cmp --silent "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist||plist_changed
	else
		cp "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	fi
}

vault_failed() {
	msg "${RED}ERROR:${NC} vault build failed, see $LOGFILE for details\n"
	exit 1
}

build_vault() {
	msg "\nBuilding vault files for $BUILD_DIR ... "
	if [ ! -e "$RES_DIR/UDK/OcSupportPkg" ]; then
		mkdir -p "$RES_DIR/UDK/OcSupportPkg"
		cd "$RES_DIR/UDK/OcSupportPkg"
		ocsupporturl=$(grep "/OcSupportPkg/prebuiltRelease/@0/debug " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		curl -L -O "$ocsupporturl"
		ocsupportzip=${ocsupporturl##*/}
		tar xvf "$ocsupportzip"
	fi
	cd "$BUILD_DIR"/OC
	if ls vault* 1> /dev/null 2>&1; then
		rm vault.*
	fi
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .||return 1
	if [ "$MODE" = "latestSource" ]; then
		make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool||return 1
	fi
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub||return 1
	str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
	off=$((str+16))
	len=$(wc -c vault.pub|cut -f1 -d 'v'|tr -d ' ')
	dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count="$len" conv=notrunc
	rm vault.pub
	fin
}

find_srce_url() {
	parent=$(grep "/$res_name/parent " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$MODE" = "latestSource" ]; then
		git_url=$(grep "/$res_name/$MODE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		if [ -z "$git_url" ]; then
			git_url=$(grep "/$parent/latestSource " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		fi
	else
		if [ -z "$parent" ]; then
			git_url=$(grep "/$res_name/$MODE/@0/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		else
			git_url=$(grep "/$res_name/path " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		fi
	fi
}

add_res_array() { # add a resource to the psuedo array (needed for POSIX)
	find_srce_url
	if [ "$dest" != "OC/ACPI" ];then
		if [ -n "$git_url" ] || [ -n "$parent" ]; then # found repo
			srce=""
		elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ "$enabled" = "false" ]; then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	else # check extras folder first for ACPI files
		if [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ -n "$git_url" ]; then # found repo
			srce=""
		elif [ "$enabled" = "false" ];then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	fi
	if [ "$IGNORE" = "yes" ]; then
		srce="unknown"
		IGNORE="true"
		IGNORE_BOOL="yes"
		key="${key% ?} i"
		set_edit_res "$num"
	fi
	set_res "$G$S"
}

missing_plist_sec() {
	msg "\n${YEL}WARNING:${NC} Missing $1 > $2 section in $filePath\n"
	msg "\tWill continue build, but please note this warning from the Configuration.pdf\n"
	msg "\t${U}Note: Currently most properties try to have defined values even if not specified\n"
	msg "\tin the configuration for safety reasons. This behaviour should not be relied upon, and\n"
	msg "\tall fields must be properly specified in the configuration.${NC}\n"
	num=1
}

add_resource() { #add_resource "Group" "Section" "subsec" "Path"
	G=$1; S=0
	if [ "$G" -lt "5" ]; then
		num=$(grep -c "^$2|*$3|[0-9]*|string|$4| " "$CONFIG_TXT")||missing_plist_sec "$2" "$3"
		for S in $(seq "0" "$((num-1))")
		do
			case "$G" in
				1|2|4)
					res_name=$(grep "^$2|*$3|$S|string|$4| " "$CONFIG_TXT"|cut -f2 -d '"')
					enabled=$(grep "^$2|*$3|$S|bool|Enabled| " "$CONFIG_TXT"|cut -f2 -d '"')
					add_res_array;;
				3)
					res_name=$(grep "^$2|*$3|$S|string|$4| " "$CONFIG_TXT"|cut -f2 -d '"')
					enabled="true"
					add_res_array;;
			esac
		done
	else
# shellcheck disable=SC2013
		for res_name in $(grep "^$2|Quirks|" "$CONFIG_TXT"|cut -f7 -d'|')
		do
			enabled=$(grep "|$res_name| " "$CONFIG_TXT"|cut -f2 -d '"')
			set_res "$G$S"
			S=$((S+1))
		done
		S=$((S-1))
	fi
	eval G"$G"_NUM="$S"
}

init_res_array() { # base-resources moved into .tool-files for portability
	G=0; S="-1"
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=\$line\|true"
		if [ "$MODE" = "latestSource" ]; then
				get_res "0$S"
				if [ "$res_name" = "base" ]; then res_name="$git_url"; fi
				add_res_array
				res_name="base"
				set_res "0$S"
		fi
	done < "$TOOL_FILES/no-pre-base-resources"
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=\$line\|true"
		get_res "0$S"
		add_res_array
	done < "$TOOL_FILES/pre-base-resources"
	G0_NUM=$((S+1))
	eval "res0$G0_NUM=config.plist\|\|'$INPUT'\|OC\|\|true"
}

set_build_type() {
	case $1 in
		d|debug)
			TYPE="debug"; XCODE_CONFIG="Debug";;
		r|release)
			TYPE="release"; XCODE_CONFIG="Release";;
		*)
			msg "Invalid build type selected in set_build_type()\n"
			exit 1;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
}

print_res_array() { # debug aid to list psuedo array
	msg "\033[J\033[0m\n"
	for G in $(seq 0 10)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
				eval line="\$res$G$S"
				msg "$G$S|$line\n"
		done
	done
}

write_new_conf() { # write new config.plist based on changes in psuedo array
	OUT="$BASE_DIR/Docs/config.plist"
	msg "\033[J\nWriting new config.plist to $OUT ... "
	rm -rf "$OUT"
	num=0; done=""; driver=""
	srch="key"
	get_edit_res "$num"
	while read -r line
	do
		if [ -n "$done" ]; then
			echo "$line" >> "$OUT"
		else
			while [ "$en" = "+" ] || [ "$en" = "-" ] || [ "$en" = "i" ] # find valid G10 key
			do
				if [ "$type" = "string" ]; then # driver handle
					driver="true"; break
				else
					num=$((num+1))
					get_edit_res "$num"
				fi
			done

			if [ "$key" = "$val" ]; then srch="$type"; fi # found standalone val

			while [ "${line%%>*}" != "<$srch" ] # find plist line with key
			do
				echo "$line" >> "$OUT"
				read -r line
			done

			if [ -z "$driver" ]; then
				echo "<$srch>$key</$srch>" >> "$OUT"
			elif [ "${key##* }" = "+" ]; then
				echo "<$srch>${key% ?}</$srch>" >> "$OUT"
			fi
			driver=""

			if [ "$srch" = "key" ]; then
				case "$type" in
					bool)
						read -r line
						echo "<$val/>" >> "$OUT";;
					string|integer)
						read -r line
						echo "<${type}>$val</${type}>" >> "$OUT";;
					data)
						read -r line
						while [ "${line#*</}" != "data>" ]
						do
							read -r line
						done
						echo "<${type}>$val</${type}>" >> "$OUT";;
				esac
			else
				srch="key"
			fi
			num=$((num+1))
			if [ "$num" -gt "$G10_NUM" ]; then done="true"; fi
			get_edit_res "$num"
		fi
	done < "$CONFIG_PLIST"
	fin
}

set_ROW_COL(){ # set ROW and COL for TUI mode based on group and section
	case "$G" in
		1|2|3|4)
			ROW=$((S+3))
			COL=$(((G-1)*C+1));;
		5|6|7|8)
			ROW=$((S+BOT+5))
			COL=$(((G-5)*C+1));;
		CH)
			ROW=2
			COL=$(((S-1)*C+1));;
	esac
}

set_text_header() { # eval to avoid unused var in shellcheck
	eval resCH1="\\${U}A\\${UO}CPI/\\${U}Q\\${UO}uirks\|"
	eval resCH2="\\${U}K\\${UO}exts/Ker\\${U}n\\${UO}el\|"
	eval resCH3="\\${U}D\\${UO}rivers/\\${U}U\\${UO}EFI\|"
	eval resCH4="\\${U}T\\${UO}ools/\\${U}B\\${UO}ooter\|"
	eval GCH_NUM="4"
}

set_color() { # set TUI section color based on resource
	case "$val" in
		true)
			color="$GRN"; MSG="+";;
		false)
			color="$RED"; MSG="-";;
		ignored)
			color="$YEL"; MSG="-i";;
		*)
			color="$BLU"; MSG="$val";;
	esac
	if [ "$G" = "CH" ];then color="$NC";fi
	if [ "$G" = "3" ]; then color="$color${U}"; fi
}

select_MSG() { # draw highligted resource in TUI
	if [ "$G" -ne "10" ]; then
		msg "\033[${ROW};${COL}H$color$INV $res_name $MSG \033[0m"
	fi
}

unselect_MSG() { # clear highlighted resource in TUI
	if [ "$G" -ne "10" ]; then
		msg "\033[${ROW};${COL}H$color $res_name $MSG "
	fi
}

draw_key() {
	if [ "$R" -gt "30" ];then
		msg "$NC\033[$((BOT+KEY+4))H\n"
		msg "$(cat "$TOOL_FILES/key.msg")\n"
	fi
}

draw_screen_header() {
	if [ "$TYPE" = "debug" ]; then
		inc_syms="${GRN}yes${NC}"
	else
		inc_syms="${RED}no${NC}"
	fi
	if [ -n "$CONFIG_CHANGED" ]; then
		CC="${RED}${INV}X${NC}${INV}"
	else
		CC="${GRN}${INV} ${NC}${INV}"
	fi
	msg "$NC\033[H${CC}$TUI_MODE${NC}  mode=$GRN$MODE$NC  debug=${inc_syms}  IN=${GRN}$filePath${NC}\033[K\n"
}

draw_col_header() {
	OLD_G=$G; OLD_S=$S
	G='CH'; color=${NC}
	for S in $(seq 1 4)
	do
		get_res "$G$S"
		set_ROW_COL
		msg "\033[${ROW};${COL}H$color $res_name "
	done
	G=$OLD_G; S=$OLD_S
}

draw_screen() {
	OLD_G=$G; OLD_S=$S; BOT=0
	R=$(stty size|cut -f1 -d ' '); C=$(stty size|cut -f2 -d ' ')
	C=$((C/4))
	msg "\033[2J\033[H"
	draw_screen_header
	draw_col_header

	for G in $(seq 1 4)
	do
		S="0"
		eval n="\$G${G}_NUM"
		while [ "$S" -le "$n" ]
		do
			get_res "$G$S"
			get_edit_res "$enabled"
			if [ "$en" = "+" ]; then
				val="true"
			elif [ "$en" = "-" ]; then
				val="false"
			elif [ "$en" = "i" ]; then
				val="ignored"
			fi
			res_name="${key% ?}"
			set_ROW_COL
			set_color
			unselect_MSG
			if [ "$BOT" -lt "$S" ];then BOT="$S"; fi
			S=$((S+1))
		done
	done
	KEY=0
	for G in $(seq 5 8)
	do
		eval num="\$G${G}_START"
		num=$((num+1))
		get_edit_res "$num"
		a="$L1"; S=0
		while [ "$a" -eq "$L1" ]
		do
			set_ROW_COL
			res_name="$key"
			enabled="$val"
			set_color
			unselect_MSG
			num=$((num+1)); S=$((S+1))
			get_edit_res "$num"
			if [ -z "$L1" ]; then break; fi
		done
		eval G${G}_NUM="$((S-1))"
		if [ "$KEY" -lt "$S" ]; then KEY="$S"; fi
	done
	draw_key
	draw_footer
	G=$OLD_G; S=$OLD_S
}

draw_footer() {
	msg "\033[$((R-1));2H$GRN$INV enabled $NC $RED$INV disabled $NC "
	msg "$YEL$INV ignored $NC $BLU$INV numeric $NC  q - to quit   r - redraw screen"
}

get_CHAR() {
	stty -icanon
	CHAR=$(dd bs=1 count=1 2>/dev/null|od -A n -a|tr -d ' ')
	stty icanon
}

compute_data_vals() {
	case $data_field in
		1)
			val="$e_val"
			hex_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '1/1 " %02x"')
			cb64_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '"%_p"');;
		2)
			hex_val="$e_val"
			val=$(printf "%b" "$hex_val"|xxd -p -r|base64)
			cb64_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '"%_p"');;
		3)
			if [ -z "$cb64_touched" ]; then
				cb64_val="$e_val"
				val=$(printf "%b" "$cb64_val"|base64)
				hex_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '1/1 " %02x"')
			fi;;
		esac
}

draw_edit_val() {
	if [ "$key" = "$val" ] && [ -z "$lone" ]; then
		msg "\033[${S}H${e_text}$e_val${NC}\033[K"
	else
		if [ "$type" = "data" ]; then
			compute_data_vals
			msg "\033[${S}H${e_text}$key${NC} | $val |$hex_val | $cb64_val\033[K"
			if [ -n "$e_split" ]; then
				case $data_field in
					1)
						msg "\033[${S}H${e_text}$key${NC} | "
						printf "%.${e_split}s" "$val" > "$TTY_OUT";;
					2)
						msg "\033[${S}H${e_text}$key${NC} | $val |"
						printf "%.${e_split}s" "$hex_val" > "$TTY_OUT";;
					3)
						msg "\033[${S}H${e_text}$key${NC} | $val |$hex_val | "
						printf "%.${e_split}s" "$cb64_val" > "$TTY_OUT";;
				esac
			fi
		else
			msg "\033[${S}H${e_text}$key${NC} | $e_val\033[K"
			if [ -n "$e_split" ]; then
				msg "\033[${S}H${e_text}$key${NC} | "
				printf "%.${e_split}s" "$e_val" > "$TTY_OUT"
			fi
		fi
	fi
}

draw_edit_key() {
	S=$((S+1))
	if [ -z "$type" ]; then
		case "$en" in
			+)
				e_text="${e_text}${GRN}";;
			-)
				e_text="${e_text}${RED}";;
			i)
				e_text="${e_text}${YEL}";;
		esac
		if [ -n "$selected" ]; then e_text="${e_text}${INV}"; selected=""; has_higher_level=""; \
			res_name="$key"; res_num="$num"; res_type="$type"; head_line="$num"; fi
		msg "\033[${S}H${e_text}$key${NC} >  "
	else
		case $type in
			bool)
				if [ "$e_val" = "true" ]; then
					e_text="${e_text}${GRN}"
				else
					e_text="${e_text}${RED}"
				fi;;
			data)
				e_text="${e_text}${YEL}";;
			integer)
				e_text="${e_text}${BLU}";;
			string)
				if [ "$en" = "+" ]; then
					e_text="${e_text}${GRN}${U}"
				elif [ "$en" = "-" ]; then
					e_text="${e_text}${RED}${U}"
				elif [ "$en" = "i" ]; then
					e_text="${e_text}${YEL}${U}"
				fi;;
		esac
		if [ -n "$selected" ]; then e_text="${e_text}${INV}"; selected=""; has_higher_level="$S"; \
			res_name="$key"; res_num="$num"; res_type="$type"; fi
		draw_edit_val
	fi
}

load_edit_text() {
	num=0; SEC=""; SUB=""
	A0="0"; A1="0"; A2="0"
	G1_NUM=-1; G2_NUM=-1; G3_NUM=-1; G4_NUM=-1
	while read -r line
	do
		eval "res10$num=\$line"
		get_edit_res "$num"
		if [ "$key" = "RequireVault" ]; then USE_VAULT="$num"; fi
		if [ "$key" = "RequireSignature" ]; then USE_SIG="$num"; fi
		if [ "$key" = "Enabled" ] && [ -n "$IGNORE_BOOL" ]; then
			val="false"
			IGNORE_BOOL=""
			set_edit_res "$num"
		fi
		if [ "$A0" -ne "$L0" ]; then
			SEC="$key"; SUB=""
			A0="$L0"; A1="0"; A2="0"
		elif [ "$A1" -ne "$L1" ]; then
			SUB="$key"; A1="$L1"; A2="0"
			eval $SEC${SUB}_START="$num"
		elif [ "$A2" -ne "$L2" ]; then
			A2="$L2"
			G=0
			case "$SEC$SUB" in
				"ACPIAdd")
					G=1; G1_NUM=$((G1_NUM+1)); dest="OC/ACPI";;
				"KernelAdd")
					G=2; G2_NUM=$((G2_NUM+1)); dest="OC/Kexts";;
				"UEFIDrivers")
					G=3; G3_NUM=$((G3_NUM+1)); dest="OC/Drivers";;
				"MiscTools")
					G=4; G4_NUM=$((G4_NUM+1)); dest="OC/Tools";;
			esac
			if [ "$G" -gt "0" ]; then
				res_name="${key% ?}"
				enabled="$num"; S="$((L2-1))"
				add_res_array
				if [ "$G" -eq "3" ] && [ "${key##* }" != "i" ]; then
					key="$key +"; val="$val +"
					set_edit_res "$num"
				fi
			fi
		fi
		num=$((num+1))
	done < "$INPUT/edit_text.txt"
	num=$((num-1))
	G1_START="$ACPIAdd_START"
	G2_START="$KernelAdd_START"
	G3_START="$UEFIDrivers_START"
	G4_START="$MiscTools_START"
	G5_START="$ACPIQuirks_START"
	G6_START="$KernelQuirks_START"
	G7_START="$UEFIQuirks_START"
	G8_START="$BooterQuirks_START"
	eval "G10_NUM=$num"
}

get_edit_res() {
	eval key="\$res10$1"
	L0="${key%%|*}"; key="${key#*|}"
	L1="${key%%|*}"; key="${key#*|}"
	L2="${key%%|*}"; key="${key#*|}"
	L3="${key%%|*}"; key="${key#*|}"
	type="${key%%|*}"; key="${key#*|}"
	val=${key%%|*}; key="${key#*|}"
	en="${key##* }"
}

set_edit_res() {
	eval res10$1="\$L0\|\$L1\|\$L2\|\$L3\|\$type\|\$val\|\$key"
}

split_val() {
	val1=$(printf "%.${e_split}b" "$e_val")
	val2="${e_val#$val1}"
}

edit_val() {
	old_val="$val"
	e_split="${#e_val}"
	cb64_touched="false"
	draw_edit_val
	while :
	do
		get_CHAR
		case $CHAR in
			del)
				split_val
				e_val="${val1%?}$val2"
				e_split=$((e_split-1))
				if [ "$data_field" -eq "3" ]; then cb64_touched=""; else cb64_touched="false"; fi
				if [ "$e_split" -lt "0" ]; then e_split="0"; fi;;
			esc)
				get_CHAR
				case $CHAR in
					"[")
						get_CHAR
						case $CHAR in
							C)
								e_split=$((e_split+1))
								if [ "$e_split" -gt "${#e_val}" ]; then e_split="${#e_val}"; fi;;
							D)
								e_split=$((e_split-1))
								if [ "$e_split" -lt "0" ]; then e_split="0"; fi;;
						esac;;
					esc)
						val="$old_val"
						e_val="$val"
						data_field="1"
						draw_edit_val
						msg "$(tput civis)"
						break;;
				esac;;
			ht)
				if [ "$type" = "data" ]; then
					case $data_field in
						1)
							e_val="$hex_val"
							data_field="2";;
						2)
							hex_val=$(printf "%b" "$e_val"|xxd -p -r|hexdump -v -e '1/1 " %02x"')
							e_val="$cb64_val"
							data_field="3";;
						3)
							e_val="$val"
							data_field="1";;
					esac
					e_split="${#e_val}"
				fi;;
			nl)
				if [ "$type" != "data" ]; then val="$e_val"; fi
				if [ -n "$lone" ]; then
					key="$val"
					lone=""
				fi
				msg "$(tput civis)"
				break;;
			sp)
				split_val
				e_val="$val1 $val2"
				if [ "$data_field" -eq "3" ]; then cb64_touched=""; else cb64_touched="false"; fi
				e_split=$((e_split+1));;
			[0-9] )
				split_val
				e_val="$val1$CHAR$val2"
				if [ "$data_field" -eq "3" ]; then cb64_touched=""; else cb64_touched="false"; fi
				e_split=$((e_split+1));;
			[a-fA-F] )
				if [ "$type" != "integer" ]; then
					split_val
					e_val="$val1$CHAR$val2"
					if [ "$data_field" -eq "3" ]; then cb64_touched=""; else cb64_touched="false"; fi
					e_split=$((e_split+1))
				fi;;
			*)
				if [ "$type" != "integer" ] && [ "$data_field" != "2" ]; then
					split_val
					e_val="$val1$CHAR$val2"
					if [ "$data_field" -eq "3" ]; then cb64_touched=""; else cb64_touched="false"; fi
					e_split=$((e_split+1))
				fi;;
		esac
		draw_edit_val
	done
	edit_res_num="-1"
	data_field="1"
	e_split=""
}

draw_edit_text() {
	num=0; S=3
	data_field="1"
	if [ "$moved" = "redraw" ]; then msg "\033[2J"; fi
	draw_screen_header
	while [ "$num" -le "$G10_NUM" ]
	do
		e_text=""
		get_edit_res "$num"; e_val="$val"
		if [ "$L1" -eq "0" ]; then
			if [ "$L0" -eq "$S0" ]; then selected="true"; fi
			e_text="$e_text"; draw_edit_key
			if [ "$level" -eq "0" ]; then LLEN=$L0; fi
		elif [ "$level" -gt "0" ] && [ "$L2" -eq "0" ] && [ "$L0" -eq "$S0" ]; then
			if [ "$L1" -eq "$S1" ]; then selected="true"; fi
			e_text="\t$e_text"; draw_edit_key
			if [ "$level" -eq "1" ]; then LLEN=$L1; fi
		elif [ "$level" -gt "1" ] && [ "$L3" -eq "0" ] && [ "$L1" -eq "$S1" ] && [ "$L0" -eq "$S0" ]; then
			if [ "$L2" -eq "$S2" ]; then selected="true"; fi
			e_text="\t\t$e_text"; draw_edit_key
			if [ "$level" -eq "2" ]; then LLEN=$L2; fi
		elif [ "$level" -gt "2" ] && [ "$L0" -eq "$S0" ] && [ "$L1" -eq "$S1" ] && [ "$L2" -eq "$S2" ]; then
			if [ "$L3" -eq "$S3" ]; then selected="true"; fi
			e_text="\t\t\t$e_text"; draw_edit_key
			if [ "$level" -eq "3" ]; then LLEN=$L3; fi
		fi
		if [ -n "$has_higher_level" ]; then
			if [ "$edit_res_num" -eq "$num" ]; then
				edit_val
				set_edit_res "$num"
			fi
		fi
	num=$((num+1))
	done
	msg "\033[3;15H"
	case "$res_type" in
		"bool")
			msg "space: ${GRN}enable${NC}/${RED}disable${NC} value\033[K";;
		"integer")
			msg "return: ${BLU}edit number${NC}   return: save changes   ${RED}esc esc${NC}: discard changes\033[K";;
		"data")
			msg "tab: ${YEL}cycle through types${NC}  base64 | hex | ascii   return: save changes    ${RED}esc esc${NC}: discard changes\033[K";;
		"string")
			msg "return: edit value   return: save changes    ${RED}esc esc${NC}: discard changes\033[K";;
		*)
			msg "up dn: select section | ->: expand | <-: collapse"
			if [ "${res_name##* }" = "+" ] || [ "${res_name##* }" = "-" ]; then
				msg "    space: ${GRN}enable${NC}/${RED}disable${NC} selection"
			fi
			if [ "${res_name##* }" = "i" ]; then
				msg "  ${YEL}Disabled by -i option${NC}"
			fi
			msg "\033[K";;
	esac
	msg "\033[${S}H\n"
	res_name="${res_name% ?}"
}

show_description() {
	DESC=""
	while read -r line
	do
		read -r desc
		if [ "$line" = "$res_name" ];then
			DESC=$desc
			break
		fi
	done < "$TOOL_FILES/description.txt"
	if [ -z "$DESC" ]; then DESC="No description found."; fi
	msg "$NC\033[2K\n$DESC\033[K\n\033[2K"
	moved="redraw"
	select_MSG
	get_CHAR
	if [ "$CHAR" = "esc" ];then esc="true"; fi
}

toggle_enabled() {
	if [ "$type" = "" ] || \
	{ [ "$type" = "bool" ] && [ "$key" = "Enabled" ]; }; then
		get_edit_res "$head_line"
		case "$en" in
			"-"|"+")
				temp=${key%?}
				case "${key##* }" in
					"-")
						key="$temp+";;
					"+")
						key="$temp-";;
				esac
				set_edit_res "$head_line"
				num="$head_line"
				while [ "$key" != "Enabled" ]
				do
					num=$((num+1))
					get_edit_res "$num"
				done
				case "$val" in
					true)
						val="false";;
					false)
						val="true";;
				esac
				set_edit_res "$num"
				CONFIG_CHANGED="-t option"
				moved="changed"
				;;
		esac
	elif [ "$type" = "bool" ]; then
		case "$val" in
			true)
				val="false";;
			false)
				val="true";;
		esac
		CONFIG_CHANGED="-t option"
		set_edit_res "$res_num"
		moved="changed"
	elif [ "$en" != "$key" ]; then
		get_edit_res "$res_num"
		if [ "$en" = "+" ]; then
			key="${key% ?} -"
			CONFIG_CHANGED="-t option"
			moved="changed"
		elif [ "$en" = "-" ]; then
			key="${key% ?} +"
			CONFIG_CHANGED="-t option"
			moved="changed"
		fi
		val="$key"
		set_edit_res "$res_num"
	fi
}

text_user_interface() {
	git_url=""; srce=""; dest=""; parent=""
	BOT=0; KEY=0
	CHAR=""; moved=""
	set_text_header
	msg "$(tput smcup)"
	msg "$(tput civis)"
	stty -echo
	G=1; S=0
	draw_screen
	get_res "$G$S"
	get_edit_res "$enabled"
	if [ "$en" = "+" ]; then
		val="true"
	elif [ "$en" = "-" ]; then
		val="false"
	elif [ "$en" = "i" ]; then
		val="ignored"
	fi
	set_ROW_COL; set_color
	select_MSG
	while [ "$CHAR" != "g" ]
	do
		get_CHAR
		case $CHAR in
			b)
				moved="true"
				eval S="\$G${G}_NUM";;
			e)
				moved="redraw"
				if [ "$TUI_MODE" != "summary" ]; then
					#write_text_config
					TUI_MODE="summary"
					draw_screen
					G=1; S=0
				else
					TUI_MODE=" plist "
					level=0; S0=1; S1=0; S2=0; S3=0
					G="10"; S=0
				fi;;
			n) # jump to kerNel quirks
				moved="true"
				G=6; S=0;;
			p) # debug dump array
				stty echo
				msg "${NC}"
				msg "$(tput rmcup)"
				print_res_array
				exit 0;;
			q)
				stty echo
				CHAR='g'
				TEXT="quit";;
			s) # exit loop with 'g' then save Docs/config.plist if changed then stop
				if [ -z "$CONFIG_CHANGED" ]; then CONFIG_CHANGED="save"; fi
				CHAR='g'
				TEXT='stop';;
			K) # jump to kext group
				moved="true"
				G=2; S=0;;
			T) # jump to Tools group
				moved="true"
				G=4; S=0;;
			U) # jump to UEFI quirke
				moved="true"
				G=7; S=0;;
			Q) # jump to ACPI quirks
				moved="true"
				G=5; S=0;;
			esc|'[')
				esc="true";;
			*)
				if [ "$G" -lt 10 ]; then
					case "$CHAR" in # key press actions for summary screen
						i)
							show_description
							draw_screen;;
						r)
							draw_screen
							moved="true";;
						A|k) # move up
							moved="true"
							if [ -n "$esc" ] || [ "$CHAR" = "k" ]; then
								S=$((S-1))
								if [ "$S" -lt "0" ];then
									if [ "$G" -gt "4" ];then
										G=$((G-4))
										eval S="\$G${G}_NUM"
									else
										S=0
									fi
								fi
							else # jump to ACPI group
								G=1; S=0
							fi
							esc="";;
						B|j) # move down
							moved="true"
							if [ -n "$esc" ] || [ "$CHAR" = "j" ]; then
								S=$((S+1))
								eval len="\$G${G}_NUM"
								if [ "$S" -gt "$len" ];then
									if [ "$G" -lt "5" ];then
										G=$((G+4))
										S=0
									else
										S=$len
									fi
								fi
							else # jump to Booter quirks
								G=8; S=0
							fi
							esc="";;
						C|l) # move right
							G=$((G+1))
							if [ "$G" -eq "5" ];then G=4;fi
							if [ "$G" -eq "9" ];then G=8;fi
							moved="true"
							esc="";;
						D|h) # move left
							moved="true"
							if [ -n "$esc" ] || [ "$CHAR" = "h" ]; then
								G=$((G-1))
								if [ "$G" -eq "0" ];then G=1;fi
								if [ "$G" -eq "4" ];then G=5;fi
								esc=""
							else
								G=3; S=0
							fi
							esc="";;
						sp|nl) # toggle enabled
							unselect_MSG
							moved="changed"
							if [ "$G" = "3" ]; then
								res_num="$enabled"
#								msg "\nnum $num res $res_num en $en enab $enabled key $key val $val hl $head_line\033[K"
#								exit 3
							elif [ "$G" -lt "5" ]; then
								head_line="$enabled"
							else
								res_num="$num"
							fi
							toggle_enabled
							CONFIG_CHANGED="-t option"
							draw_screen_header;;
						ht)
							G=$((G+1))
							if [ "$G" -gt "8" ]; then G=1; fi
							moved="true";;
					esac
				else
					case "$CHAR" in # key press actions for edit plist screen
						i)
							show_description
							draw_edit_text;;
						r)
							moved="redraw"
							draw_edit_text
							moved="";;
						A|k) # move up
							eval SN="\$S$level"
							SN=$((SN-1))
							if [ "$SN" -lt "1" ]; then
								SN=1
							else
								moved="true"
							fi
							eval S$level=$SN
							esc="";;
						B|j) # move down
							eval SN="\$S$level"
							SN=$((SN+1))
							if [ "$SN" -gt "$LLEN" ]; then
								SN=$LLEN
							else
								moved="true"
							fi
							eval "S$level=$SN"
							esc="";;
						C|l) # move right
							if [ -z "$has_higher_level" ]; then
								level=$((level+1))
								if [ "$level" -gt "3" ]; then level=3; fi
								eval S$level=1
								moved="redraw"
							fi
							esc="";;
						D|h) # move left
							if [ "$level" -gt "0" ]; then
								eval S$level=0
								level=$((level-1))
								moved="redraw"
							fi
							esc="";;
						sp) # only mark CONFIG_CHANGED if change was done  sp|nl
							get_edit_res "$res_num"
							toggle_enabled
							;; # end case sp
						nl|ht)
							get_edit_res "$res_num"
							if [ "$en" != "$key" ]; then
								toggle_enabled
							else
								case $type in
									"string"|"integer"|"data")
										if [ "$key" = "$val" ]; then lone="true"; fi
										edit_res_num="$res_num"
										moved="changed"
										msg "$(tput cnorm)";;
								esac
							fi;;
					esac
				fi
		esac
		eval temp="\$G${G}_NUM"
		if [ "$S" -gt "$temp" ];then
			S="$temp"
		fi
		if [ "$S" -lt "0" ];then S=0; fi
		if [ -n "$moved" ]; then
			if [ "$G" -lt "5" ]; then
				unselect_MSG
				get_res "$G$S"
				get_edit_res "$enabled"
				if [ "$en" = "+" ]; then
					val="true"
				elif [ "$en" = "-" ]; then
					val="false"
				elif [ "$en" = "i" ]; then
					val="ignored"
				fi
				set_ROW_COL
				set_color
				select_MSG
			elif [ "$G" -lt "10" ]; then
				unselect_MSG
				eval num="\$G${G}_START"
				num=$((num+S+1))
				get_edit_res "$num"
				res_name="$key"
				set_ROW_COL
				set_color
				select_MSG
			else
				draw_edit_text
			fi
			moved=""
		fi
	done
	stty echo
	msg "${NC}"
}

start_logging() {
	if [ -z "$VERBOSE" ]; then
		exec 6>&1 #start logging
		exec > "$LOGFILE"
		exec 2>&1
	fi
}

stop_logging() {
	if [ -z "$VERBOSE" ];then
		exec 1>&6 6>&- 2>&1 #stop logfile
	fi
}

remove_resource_msg() {
	msg "\n ${RED}***${NC} WARNING: -X option used ${RED}****************************************\n"
	msg " ${RED}*** ${NC}$RES_DIR has been removed\n"
	msg " ${RED}*** ${NC}the -X option is only useful if there is an issue with the\n"
	msg " ${RED}*** ${NC}previously downloaded resources causing problems while building.\n"
	msg " ${RED}*** ${NC}Using it at any other time will only increase bandwith usage and\n"
	msg " ${RED}*** ${NC}compile time, in many cases requiring all tools to be rebuilt.\n"
	msg " ${RED}*********************************************************************${NC}\n"
}

#****** Start build ***************
while getopts "$optspec" optchar; do
case "${optchar}" in
		d)
			MODE="prebuiltDaily"
			EX_COM="${EX_COM}d"
			msg "\n${YEL}$MODE${NC} not implemented yet.\n"
			exit 1;;
		h) # help
			msg "$(cat "$TOOL_FILES"/help.msg)\n"
			exit 0;;
		i)
			IGNORE="true";;
		n)
			UPDATE="false"
			EX_COM="${EX_COM}n";;
		o)
			FINDER="open"
			EX_COM="${EX_COM}o";;
		q)
			QUIET="-q"
			EX_COM="${EX_COM}q";;
		r)
			TYPE="release"
			EX_COM="${EX_COM}r";;
		s)
			MODE="latestSource"
			EX_COM="${EX_COM}s";;
		v)
			VERBOSE="-v"
			EX_COM="${EX_COM}v";;
		t)
			TEXT="true"
			TUI_MODE="summary"
			EX_COM="${EX_COM}t";;
		D) # for when I break stuff
			DEBUG="true";;
		V)
			msg "OC-tool version $VER\n"
			HAS_NVRAM=""
			command -v nvram 1>/dev/null||HAS_NVRAM="false"
			if [ -z "$HAS_NVRAM" ]; then
				v=$(nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:opencore-version 2>/dev/null || echo "")
				if [ -z "$v" ]; then
					msg "\nNo booted opencore-version found in NVRAM\n"
				else
					msg "\nFound booted ${v#*:}  in NVRAM\n"
				fi
			fi
			exit 0;;
		X)
			REMOVE_RES="true";;
		*)
			msg "$(cat "$TOOL_FILES/usage.msg")\n"
			exit 1;;
	esac
done
eval filePath="\$$OPTIND"

start_logging
if [ -n "$DEBUG" ]; then msg "\ndb - start logging\n"; fi

RES_DIR="$BASE_DIR/resources/$MODE"

if [ -p /dev/stdin ]; then # data was piped
	mkdir -p "$INPUT"
	cat > "$CONFIG_PLIST"
	QUIET="-q" # currently stdin is not a terminal, no output to tty
	TEXT="" # no TUI use either with piped config.plist
	filePath="stdin"
else  #  no input found on stdin
	if [ -e "$filePath" ]; then
		EX_COM="${EX_COM} ${filePath}"
	else
		if [ -n "${filePath}" ]; then
			msg "config.plist file '${filePath}' not found\n"
			msg "$(cat "$TOOL_FILES"/usage.msg)\n"
			exit 1
		else
			check_config
			filePath="$BASE_DIR/INPUT/config.plist"
		fi
	fi
	mkdir -p "$INPUT"
	cp "${filePath}" "$CONFIG_PLIST"
fi
if [ -n "$DEBUG" ]; then msg "\ndb - filePath $filePath CONFIG_PLIST $CONFIG_PLIST\n"; fi

cd "$INPUT"
tr -d '\r' < config.plist > config.plist.tmp # strip CRLF on windows
mv config.plist.tmp config.plist
"$TOOL_FILES/parsePlist.sh" > "$CONFIG_TXT"
load_edit_text

if [ "$MODE" != "latestSource" ] && [ "$UNAME" = "Darwin" ]; then # show start message
	msg "To build from source use ${B}-s${NC} option\n"
fi
msg "For help use '${B}./OC-tool -h${NC}'\n\nUsing ${filePath}\n"

if [ -z "$UPDATE" ]; then check_tool_for_updates; fi

if [ -n "$REMOVE_RES" ]; then rm -rf "$RES_DIR"; fi

set_build_type "$TYPE"

if [ "$MODE" = "latestSource" ] && [ -z "$UPDATE" ]; then
	check_lilu_for_updates
	check_resources_for_updates
fi

if [ -n "$REMOVE_RES" ]; then remove_resource_msg; fi #show warning in tool.log also
if [ "$MODE" = "latestSource" ]; then check_requirements; fi

if [ -n "$DEBUG" ]; then msg "\ndb - MODE $MODE TYPE $TYPE UNAME $UNAME\n"; fi

init_res_array

if [ -n "$TEXT" ] && [ -z "$QUIET" ]; then
	msg "\nSwitching to TUI ... "
	text_user_interface
	msg "\033[J\n" # cleanup for TERM types that don't buffer
	msg "$(tput cnorm)"
	msg "$(tput rmcup)"
	msg "${GRN}done in TUI${NC}\n"
fi

if [ "$TEXT" = "quit" ];then # quit without saving changes
	msg "\nOC-tool quit by user.\n"
	exit 0
fi

if [ -n "$USE_VAULT" ]; then
	get_edit_res "$USE_VAULT"
	USE_VAULT="$val"
fi
if [ "$USE_VAULT" = "false" ] && [ -n "$USE_SIG" ]; then
	get_edit_res "$USE_SIG"
	USE_VAULT="$val"
fi

if [ "$MODE" != "latestSource" ] && [ "$UNAME" != "Darwin" ]; then
	if [ "$USE_VAULT" = "true" ]; then
		USE_VAULT="false"
		CONFIG_CHANGED="temp vault disable"
		msg "\n${YEL}NOTICE:${NC}\tcurrently unable to build vault files on $UNAME\n"
		msg "\tvault disabled for prebuilts not made on macOS\n"
	fi
fi

if [ -n "$CONFIG_CHANGED" ]; then
	if [ -n "$DEBUG" ]; then msg "\ndb - writing new conf ... done\n"; fi
	write_new_conf
	command -v "plutil"&&plutil -convert xml1 "$BASE_DIR/Docs/config.plist"
	get_res "0$G0_NUM" # update location for config.plist file
	srce="$BASE_DIR/Docs"
	set_res "0$G0_NUM"
fi

if [ "$TEXT" = "stop" ];then exit 0;fi # save and quit

prepare_resources
if [ -n "$DEBUG" ]; then msg "\ndb - prepare_resources ... done\n"; fi
set_up_dest_dir
copy_resources

if [ "$MODE" = "latestSource" ];then check_if_Sample_plist_updated; fi

if [ "$USE_VAULT" = "true" ];then
	build_vault||vault_failed
fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n\n"
if [ -n "$CONFIG_CHANGED" ]; then
	msg "${YEL}NOTE:${NC}\tconfig.plist in $BUILD_DIR ${YEL}was changed${NC} by $CONFIG_CHANGED\n"
	msg "\tthis has been done to ensure OC wont fail on boot with this new EFI folder\n"
	msg "\tthe modified config.plist has also been placed in $BASE_DIR/Docs\n"
	msg "\tthe original $filePath ${YEL}has not been touched${NC}\n\n"
fi

stop_logging

if [ -n "$FINDER" ] && [ "$UNAME" = "Darwin" ];then open "$OUTPUT"; fi # open to EFI if -o or dbl-click

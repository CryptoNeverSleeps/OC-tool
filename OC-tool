#!/bin/sh -e
ini=$(pwd)
cd -- "$(dirname "$0")"

BASE_DIR=$(pwd)

if [ "$ini" != "$BASE_DIR" ];then # double-click from finder?
	FINDER="true"
else
	FINDER=""
fi

RES_DIR="$BASE_DIR/resources"
TOOL_FILES="$BASE_DIR/.tool-files"
REPO_PLIST="$TOOL_FILES/repo.plist"
LOGFILE="tool.log"
RED='\033[0;31m'; YEL='\033[0;33m'; GRN='\033[0;32m'; BLU='\033[0;34m'
NC='\033[0m'; B='\033[1m'; U='\033[4m'; UO='\033[24m'
INV='\033[7m'
VER="1.8i(041119) last checked with OpenCore version REL-053-2019-11-02"
ARG1="build"; ARG2="release" # set default to 'build release'
ex_com=$0' -i'; QUIET=""; VERBOSE=""; CONFIG_CHANGED=""
UPDATE=""; REMOVE_ALL=""; BASE_TOOLS=""; TEXT=""; IGNORE=""

eval set -- "$(getopt hioqtuvTUVX "$@")" #allowable command line options

msg() { #write $1 to screen if not quiet
	if [ -z "$QUIET" ]; then
		echo "$1\c" > "$(tty)"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

missing() {
	msg "\n${RED}ERROR:${NC} $1 must be installed to continue\n\t$2\n\t$3\n"
	exit 1
}

check_requirements() { #required commands moved to .tool-files/requirements for portability
	res=""
	while read -r line
	do
		res="$res*$line"
	done < "$TOOL_FILES/requirements"
	res="$res*"
	res=$(echo "$res"|cut -f 2- -d '*')

	until [ -z "$res" ]
	do
		req=$(echo "$res"|cut -f 1 -d ',')
		reqm1=$(echo "$res"|cut -f 2 -d ',')
		reqm2=$(echo "$res"|cut -f 3 -d ',')
		command -v "$req"||missing "$req" "$reqm1" "$reqm2"
		res=$(echo "$res"|cut -f 2- -d '*')
	done
}

check_config() { #config.plist must exist, even with -i option
	if [ ! -f "$CONFIG_PLIST" ]; then
		msg "\n${RED}ERROR:${NC} $CONFIG_PLIST does not exist\n\nPlease create this file and run the tool again.\n"
		exit 1
	fi
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR/BOOT"
	mkdir -p "$BUILD_DIR/OC"
	fin
}

init_res_array() { # base-resources moved into .tool-files for portability
	S=0
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=$line,true"
	done < "$TOOL_FILES/base-resources"
	eval G0_NUM=$S
}

#swap_res() { #ensure certain dependencies are in correct order
#	for S in $(seq "$2" "$(eval echo \$G"$3"_NUM)")
#	do
#		get_res "$3$S"
#		if [ "$res_name" = "$1" ]; then
#			eval temp_res=\$res"$3$2"
#			eval res"${3}""${2}"=\$res"${3}""${S}"
#			eval res"$3""$S"=\$temp_res
#			unset temp_res
#			P=$(($2+1))
#			return 0
#		fi
#	done
#}

clone() {
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		msg "Cloning $1 into $pkg_name ... "
		eval git clone "$1" "$pkg_name"
		fin
	fi
}

check_for_updates() {
	msg "\n${GRN}Checking for updates${NC} ... \n"
	cd "$BASE_DIR"
	msg "OC-tool - " # check OC-tool itself first
	git fetch --all $VERBOSE $QUIET
	if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ];then
		git pull $VERBOSE $QUIET
		msg "${YEL}INFO:${NC} OpenCore-tool has been updated, run tool again to continue\n"
		exit 0
	fi
#		find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev|xargs -I {} git -C {} pull $VERBOSE $QUIET
	if [ -d "$RES_DIR" ]; then
		cd "$RES_DIR" # now check all other resources
		for git_dir in $(find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev)
		do
			msg "$git_dir - "
			git -C "$git_dir" fetch --all $VERBOSE $QUIET
			if [ "$(git -C "$git_dir" rev-parse @)" != "$(git -C "$git_dir" rev-parse "@{u}")" ];then
				git -C "$git_dir" pull $VERBOSE $QUIET
				if [ "$UPDATE" = "stop" ];then UPDATE="true";fi
			fi
		done
	fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
# shellcheck disable=SC1091
	. edksetup.sh
	make -C BaseTools
}

build_shell_tool() { #possible to automate this function?
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/$AUDK_BUILD_DIR/X64"
	if [ -f "$srce/Shell.efi" ]; then return 0; fi
	clone "https://github.com/tianocore/edk2 -b UDK2018 --depth=1" "UDK"
	cd UDK
	msg "Making UDK2018 BaseTools ... "
	make_base_tools; fin

	msg "Patching UDK2018 ... "
	for p in ../Patches/* ; do
		git apply "$p"||echo "$p ignored, does not apply or alread done"
	done; fin

	msg "Building $AUDK_CONFIG Shell.efi (OpenCoreShell.efi) ... "
	build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p ShellPkg/ShellPkg.dsc
	fin
}

build_failed() { # failed build even after backing up 5 commits
	git checkout master
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

build_kext() {
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	if [ -n "$REMOVE_ALL" ];then
		msg "Removing Xcode DerivedData for $pkg_name ... "
		rm -rf "${HOME}"/Library/Developer/Xcode/DerivedData/"${pkg_name}"*
		fin
	fi
	srce="$(pwd)/build/$XCODE_CONFIG"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$res_name" ]; then
		msg "Building $AUDK_CONFIG $pkg_name ... "
		rm -rf Lilu.kext # remove Lilu pkg if it came with repo
		if [ ! -L "Lilu.kext" ]; then #link to acidanthera/Lilu debug version
			ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .
		fi
		if [ ! -L "VirtualSMC.kext" ]; then # AsusSMC needs link to Virtual SMC
			ln -s "$RES_DIR"/Kext_builds/VirtualSMC/build/Debug/VirtualSMC.kext .
		fi
		a=1
		while :
		do
		xcodebuild -config "$XCODE_CONFIG" build && break
			if [ "$a" -eq "5" ]; then return 1; fi
			git_sha=$(git rev-parse @|cut -c -7)
			msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
			git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		done
		if [ "$a" -ne "1" ]; then git checkout master; fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then #copy Products contents back to build level
			cp -r build/Products/* build
		fi
		fin
	fi
}

build_driver() {
	cd "$RES_DIR"/UDK
	clone "$git_url"
	srce="$(pwd)/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		{ [ ! -e "$srce/$res_name" ] && [ "$res_name" != "base" ]; }; then
		rm -rf "$srce" # extreme, but does force whole pkg build if a piece is missing
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then #no need to build again
				msg "Making base tools ... "
				cd ..
				make_base_tools; fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=1
			while :
			do
				msg "Building $AUDK_CONFIG $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc && break
				if [ "$a" -eq "5" ]; then return 1; fi
				git_sha=$(git rev-parse @|cut -c -7)
				msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
				a=$((a+1))
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

missing_iasl() {
	msg "${RED}ERROR:${NC}\t${B}iasl${NC} command is required to compile $res_name\n"
	msg "\tEither:\t* install iasl, or\n\t\t* place $res_name in ${B}extras${NC} directory\n"
	exit 1
}

build_acpi() { # compile .dsl into .aml if user hasn't already
	pkg_name=$(echo "$res_name"|cut -f1 -d.)
	srce=$RES_DIR/$(echo "$git_url"|rev|cut -f2- -d/|rev)
	if [ -e "$srce/$res_name" ];then
		return 0
	elif [ -e "$RES_DIR/$git_url" ];then
		command -v iasl||missing_iasl
		msg "Building $res_name ... "
		iasl "$RES_DIR/$git_url"||return 1
		fin
	else
		return 1
	fi
}

get_res() { # extract resource from psuedo array (needed for POSIX)
	res=$(eval echo "\$res$1")
	res_name=$(echo "$res"|cut -f1 -d,)
	git_url=$(echo "$res"|cut -f2 -d,)
	srce=$(echo "$res"|cut -f3 -d,)
	dest=$(echo "$res"|cut -f4 -d,)
	Enabled=${res##*,}
}

set_res() { # encode resource into psuedo array (needed for POSIX)
	eval "res$1=$res_name,$git_url,$srce,$dest,$Enabled"
}

build_resources() {
	msg "\n${GRN}Building needed or updated resources${NC}\n"
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	clone "https://github.com/acidanthera/audk" "UDK"
	for G in $(seq 0 4)
	do
		for S in $(seq 1 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			if [ "$Enabled" != "false" ];then
				if [ -z "$srce" ]; then
					case ${res_name##*.} in
					"base"|"efi")
						if [ "$res_name" = "Shell.efi" ]; then #special case
							build_shell_tool||build_failed
						else
							build_driver||build_failed
						fi
						;;
					"kext")
						if [ "$res_name" = "Lilu.kext" ] && [ "$ARG2" = "release" ]; then
							set_build_type "debug"
							build_kext||build_failed
							set_build_type "release"
						fi
						build_kext||build_failed
						;;
					"aml")
						build_acpi||build_failed
						;;
					esac
					set_res "$G$S"
				fi
			fi
		done
	done
	msg "\n"
}

res_not_found() {
	if [ -z "$IGNORE" ]; then
		msg "\n${RED}ERROR:${NC}\t$1 - resource was not found in .tool-files/repo.plist\n"
		msg "\t$1 file not found in extras directory\n"
		msg "\tEither place $1 in extras directory to build EFI with $1\n"
		msg "\tor run with -i option to build EFI without $1\n"
		msg "\tfor example, try '$ex_com $ARG1 $ARG2'\n"
		exit 1
	else
		msg "${YEL}WARNING:${NC} $1 repo not in .tool-files/repo.plist or extras directory - ${YEL}IGNORING${NC}\n"
		IGNORE="yes"
		CONFIG_CHANGED="true" # need to write new config before build
	fi
}

copy_resources() {
	msg "\n${GRN}Moving ${YEL}$ARG2${GRN} resources into place${NC}\n"
	IGNORE="" # no more ignoring for you
	for G in $(seq 0 4)
	do
		for S in $(seq 1 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			if [ "$Enabled" = "true" ];then
				if [ -n "$dest" ]; then
					if [ "$srce" = "unknown" ];then
						res_not_found "$res_name"
					else
						msg "Copying $res_name to $dest ... "
						mkdir -p "$BUILD_DIR/$dest"
						cp -r "$srce/$res_name" "$BUILD_DIR/$dest"
						fin
					fi
				fi
			fi
		done
	done
}

plist_changed() { # plist from OpenCorePkg has changed, warn user to check their plist
	mkdir -p "$BASE_DIR"/Docs
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist
	msg "\n${RED}WARNING:${NC} Sample$1.plist has been updated\n"
	msg "${YEL}!!!${NC} Make sure $CONFIG_PLIST is up to date${NC}.\n"
	msg "Run the tool again if you make any changes. ${YEL}!!!${NC}\n"
	cfg_ok="false"
}


check_if_Sample_plist_updated() {
	cfg_ok=""
	msg "\nChecking if Sample.plist or SampleFull.plist format has changed ... "
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist||plist_changed
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist||plist_changed "Full"
	if [ -z "$cfg_ok" ]; then fin; fi
}

parse() { # read plist file hack
	a=0; in_loop=0
	while read -r ONE
	do
		case "$1" in
			'')
				if [ "$a" -eq "0" ]; then
					case "$ONE" in
						"<true/>")
							echo true;;
						"<false/>")
							echo false;;
						*)
							echo "$ONE"|sed -e 's/<[^>]*>//g';;
					esac
					return
				else
					a=$((a-1))
				fi;;
			*[!0-9]*)
				case "$ONE" in
					"<key>$1</key>")
						if [ "$a" -eq "0" ];then
							shift
						else
							a=$((a-1))
						fi;;
					"</array>")
						if [ "$in_loop" = "1" ];then return; fi
						;;
				esac;;
			*)
				a=$1; in_loop=1
				shift;;
		esac
	done < "$FILE"
}

build_vault() {
	msg "\nBuilding vault files for $BUILD_DIR ... "
	cd "$BUILD_DIR"/OC
	if ls vault* 1> /dev/null 2>&1; then
		rm vault.*
	fi
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .
	make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub
	str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
	off=$((str+16))
	dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count=520 conv=notrunc
	rm vault.pub
	fin
}

add_res_array() { # add a resource to the psuedo array (neede for POSIX)
	FILE="$REPO_PLIST"
	git_url=$(parse "$res_name")
	if [ "$ARG1" = "build" ] && [ "$dest" != "OC/ACPI" ];then
		if [ -n "$git_url" ]; then # found repo
			srce=""
		elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ "$Enabled" = "false" ]; then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	else # copy mode, check extras folder first
		if [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ -n "$git_url" ]; then # found repo
			srce=""
		elif [ "$Enabled" = "false" ];then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	fi
	if [ "$IGNORE" = "yes" ]; then
		srce="unknown"
		Enabled="ignored"
		IGNORE="true"
	fi
	set_res "$G$S"
}

add_resource() { #add_resource "Group" "Section" "subsec" "Path"
	i=0; S=1; G=$1
	res_name="start"
	until [ -z "$res_name" ]
	do
		FILE="$CONFIG_PLIST"
		res_name=$(parse "$2" "$3" "$i" "$4")
		if [ -n "$res_name" ];then
			case "$1" in
				1)
					Enabled=$(parse "$2" "$3" "$i" "Enabled")
					dest="OC/ACPI";;
				2)
					Enabled=$(parse "$2" "$3" "$i" "Enabled")
					dest="OC/Kexts";;
				3)
					Enabled="true"
					dest="OC/Drivers";;
				4)
					Enabled=$(parse "$2" "$3" "$i" "Enabled")
					dest="OC/Tools";;
				5|6|7|8)
					Enabled=$(parse "$2" "$3" "$res_name")
					set_res "$G$S"
					i=$((i+1));;
			esac
			if [ "$G" -lt "5" ];then add_res_array;fi
			S=$((S+1))
		fi
		i=$((i+1))
	done
	eval G"$G"_NUM=$((S-1))
}

set_build_type() {
	case $1 in
		d|debug)
			ARG2="debug"; XCODE_CONFIG="Debug";;
		r|release)
			ARG2="release"; XCODE_CONFIG="Release";;
		*)
			msg "need to specify ${U}debug${NC} or ${U}release${NC} after $ARG1 command\n"
			exit 1;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
}

print_res_array() { # debug aid to list psuedo array
	msg "\033[J\033[0m\n"
	for G in $(seq 0 8)
	do
		for S in $(seq 1 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			msg "$G$S $res_name $git_url $srce $dest $Enabled\n"
		done
	done
}

write_new_array() { # write array section changes to new plist
	while [ "$line" != "</array>" ]
	do
		get_res "$G$S"
		while [ "$line" != "</dict>" ]
		do
			read -r line
			echo "$line" >> "$OUT"
	#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
			if [ "$line" = "<key>Enabled</key>" ];then
				read -r line
				if [ "$Enabled" = "ignored" ]; then
					echo "<false/>" >> "$OUT" # ignored resource
				else
					echo "<$Enabled/>" >> "$OUT"
				fi
			fi
		done
		S=$((S+1))
		read -r line
		echo "$line" >> "$OUT"
	done
}

write_new_drivers() { # write driver section changes to new plist
	while [ "$line" != "<key>Drivers</key>" ]
	do
		read -r line
		echo "$line" >> "$OUT"
	done
	get_res "$G$S"
	while [ "$line" != "</array>" ]
	do
		read -r line
		if [ "$line" = "<string>$res_name</string>" ];then
			if [ "$Enabled" = "true" ];then
				echo "$line" >> "$OUT"
			fi
			S=$((S+1))
			get_res "$G$S"
		else
			echo "$line" >> "$OUT"
		fi
	done
}

write_new_quirks() { # write quirks section changes to new plist
	get_res "$G$S"
	while [ "$line" != "<key>Quirks</key>" ];
	do
		read -r line
		echo "$line" >> "$OUT"
	done
	while [ "$line" != "</dict>" ]
	do
#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
		if [ "$line" = "<key>$res_name</key>" ];then
			read -r line
			case "$Enabled" in
				true|false)
					echo "<$Enabled/>" >> "$OUT"
					;;
				ignored)
					echo "<false/>" >> "$OUT" # ignored resource
					;;
				[0-9])
					echo "<integer>$Enabled</integer>" >> "$OUT"
					;;
				*)
					echo "$line" >> "$OUT"
					;;
			esac
			S=$((S+1))
			get_res "$G$S"
		fi
		read -r line
		echo "$line" >> "$OUT"
	done
}

write_new_conf() { # write new config.plist based on changes in psuedo array
	OUT=$BASE_DIR/Docs/config.plist
	msg "\033[J\nWriting new config.plist ... "
	rm -rf "$OUT"
	while read -r line
	do
		echo "$line" >> "$OUT"
#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
		case "$line" in
			"<key>ACPI</key>")
				G=1; S=1;
				write_new_array
				G=5; S=1;
				write_new_quirks
				;;
			"<key>Kernel</key>")
				G=2; S=1;
				write_new_array
				G=6; S=1;
				write_new_quirks
				;;
			"<key>UEFI</key>")
				G=3; S=1;
				write_new_drivers
				G=7; S=1;
				write_new_quirks
				;;
			"<key>Tools</key>")
				G=4; S=1;
				write_new_array
				;;
			"<key>Booter</key>")
				G=8; S=1;
				write_new_quirks
				;;
			"<key>RequireVault</key>")
				read -r line
				echo "<$USE_VAULT/>" >> "$OUT"
				;;
		esac
	done < "$CONFIG_PLIST"
	fin
}

set_ROW_COL(){ # set ROW and COL for TUI mode based on group and section
	case "$G" in
		1|2|3|4)
			ROW=$((S+2))
			COL=$(((G-1)*C+1))
			;;
		5|6|7|8)
			ROW=$((S+BOT+3))
			COL=$(((G-5)*C+1))
			;;
		9)
			ROW=2
			COL=$(((S-1)*C+1))
			;;
	esac
}

set_text_header() {
	eval res91="\\${U}A\\${UO}CPI/\\${U}Q\\${UO}uirks,"
	eval res92="\\${U}K\\${UO}exts/K\\${U}e\\${UO}rnel,"
	eval res93="\\${U}D\\${UO}rivers/\\${U}U\\${UO}EFI,"
	eval res94="\\${U}T\\${UO}ools/\\${U}B\\${UO}ooter,"
	eval G9_NUM="4"
}

set_color() { # set TUI section color based on resource
	case "$Enabled" in
		true)
			color="$GRN"; MSG="+"
			;;
		false)
			color="$RED"; MSG="-"
			;;
		ignored)
			color="${YEL}"; MSG="-i"
			;;
		*)
			color="$BLU"; MSG="$Enabled"
			;;
	esac
	if [ "$G" = "9" ];then color="$NC";fi
}

select_MSG() { # draw highligted resource in TUI
	msg "\033[${ROW};${COL}H$color$INV $res_name $MSG \033[0m"
}

unselect_MSG() { # clear highlighted resource in TUI
	msg "\033[${ROW};${COL}H$color $res_name $MSG "
	MSG=""
}

draw_key() {
	if [ "$R" -gt "30" ];then
		msg "$NC\033[$((BOT+KEY+3))H\n"
		msg "$(cat "$TOOL_FILES/key.msg")\n"
	fi
}

draw_header() {
	msg "$NC\033[H${U}m${UO}ode=$GRN$INV$ARG1$NC ${U}t${UO}ype=$GRN$INV$ARG2$NC RequireVault="
	if [ "$USE_VAULT" = "true" ];then
		msg "$GRN"
	else
		msg "$RED"
	fi
	msg "$INV$USE_VAULT$NC\033[K"
	OLD_G=$G; OLD_S=$S
	G=9; color=${NC}
	for S in $(seq 1 4)
	do
		get_res "$G$S"
		set_ROW_COL
		unselect_MSG
	done
	G=$OLD_G; S=$OLD_S
}

redraw_screen() {
	OLD_G=$G; OLD_S=$S
	if [ "$G" -lt "5" ];then
		draw_screen
	else
		for S in $(seq $((OLD_S)) "$KEY"); do
			msg "\033[$((ROW+1))H\033[2K"
			for G in $(seq 5 8); do
				get_res "$G$S"
				set_ROW_COL
				set_color
				unselect_MSG
			done
		done
	fi
	msg "\033[J"
	draw_key
	draw_footer
	G=$OLD_G; S=$OLD_S
}


draw_screen() {
	R=$(stty size|cut -f1 -d ' '); C=$(stty size|cut -f2 -d ' ')
	C=$((C/4))
	msg "\033[2J\033[H"
	draw_header
	for G in $(seq 1 8)
	do
		len="$(eval echo \$G"$G"_NUM)"
		if [ "$G" -le "4" ];then # BOT = longest group of 1 - 4
			if [ "$BOT" -lt "$len" ];then BOT="$len";fi
		else # KEY = longest group of 5 - 7
			if [ "$KEY" -lt "$len" ]; then KEY="$len";fi
		fi
		for S in $(seq 1 "$len")
		do
			get_res "$G$S"
			set_ROW_COL
			set_color
			unselect_MSG
		done
	done
	draw_key
	draw_footer
}

draw_footer() {
	msg "\033[$((R-1));2H$GRN$INV enabled $NC $RED$INV disabled $NC "
	msg "$YEL$INV ignored $NC $BLU$INV numeric $NC  q - to quit   r - redraw screen"
}

get_CHAR() {
	stty -icanon
	CHAR=$(dd bs=1 count=1 2>/dev/null|od -A n -a|tr -d ' ')
	stty icanon
}

text_user_interface() {
	git_url=""; srce=""; dest=""
	add_resource "5" "ACPI" "Quirks"; add_resource "6" "Kernel" "Quirks"
	add_resource "7" "UEFI" "Quirks"; add_resource "8" "Booter" "Quirks"
	BOT=0; KEY=0
	stty -echo
	CHAR=""
	set_text_header
	draw_screen
	G=1; S=1; get_res "$G$S"
	set_ROW_COL; set_color
	select_MSG
	while [ "$CHAR" != "g" ]
	do
		get_CHAR
		unselect_MSG
		case $CHAR in
			b)
				S=$(eval echo \$G"$G"_NUM)
				;;
			e) # jump to kExt quirks
				G=6; S=1;;
			i)
#				select_MSG
#				FILE=$TOOL_FILES/quirk.plist
#				DESC=$(parse "$res_name")
				DESC=""
				while read -r line
				do
					read -r desc
					if [ "$line" = "$res_name" ];then
						DESC=$desc
						break
					fi
				done < "$TOOL_FILES/description.txt"
				if [ -z "$DESC" ];then DESC="No description found.";fi
				msg "$NC\033[2K\n$DESC\033[K\n\033[2K"
				select_MSG
				get_CHAR
				redraw_screen
				;;
			m)
				if [ "$ARG1" = "build" ];then
					ARG1="copy"
				else
					ARG1="build"
				fi
				draw_header
				;;
			p)
				print_res_array
				exit 0;;
			q)
				stty echo
				msg "\033[J${NC}\n"
				exit 0;;
			r)
				OLD_G=$G; OLD_S=$S
				draw_screen
				G=$OLD_G; S=$OLD_S
				;;
			s) # exit loop with 'g' then save Docs/config.plist if changed then stop
				CHAR='g'
				TEXT='stop'
				;;
			t)
				if [ "$ARG2" = "release" ];then
					ARG2="debug"
				else
					ARG2="release"
				fi
				draw_header
				;;
			v) # toggle USE_VAULT
				if [ "$USE_VAULT" = "true" ];then
					USE_VAULT="false"
				else
					USE_VAULT="true"
				fi
				draw_header
				CONFIG_CHANGED="true"
				;;
			sp|nl) # only mark CONFIG_CHANGED if change was done
				if [ "$Enabled" = "true" ];then
					Enabled="false"
					CONFIG_CHANGED="true"
				elif [ "$Enabled" = "false" ];then
					Enabled="true"
					CONFIG_CHANGED="true"
				fi
				set_res "$G$S"
				;;
#			+) # possible change + - to inc dec numeric entries
#				if [ "$Enabled" = "false" ];then
#					Enabled="true"
#				fi
#				set_res "$G$S"
#				;;
#			-)
#				if [ "$Enabled" = "true" ];then
#					Enabled="false"
#				fi
#				set_res "$G$S"
#				;;
			A|k) # move up
				if [ -n "$esc" ] || [ "$CHAR" = "k" ]; then
					S=$((S-1))
					if [ "$S" -eq "0" ];then
						if [ "$G" -gt "4" ];then
							G=$((G-4))
							S="$(eval echo \$G"$G"_NUM)"
						else
							S=1
						fi
					fi
				else # jump to ACPI group
					G=1; S=1
				fi
				esc=""
				;;
			B|j) # move down
				if [ -n "$esc" ] || [ "$CHAR" = "j" ]; then
					S=$((S+1))
					len="$(eval echo \$G"$G"_NUM)"
					if [ "$S" -gt "$len" ];then
						if [ "$G" -lt "5" ];then
							G=$((G+4))
							S=1
						else
							S=$len
						fi
					fi
				else # jump to Booter quirks
					G=8; S=1
				fi
				esc=""
				;;
			C|l) # move right
				G=$((G+1))
				if [ "$G" -eq "5" ];then G=4;fi
				if [ "$G" -eq "9" ];then G=8;fi
				esc=""
				;;
			D|h) # move left
				if [ -n "$esc" ] || [ "$CHAR" = "h" ]; then
					G=$((G-1))
					if [ "$G" -eq "0" ];then G=1;fi
					if [ "$G" -eq "4" ];then G=5;fi
					esc=""
				else
					G=3; S=1
				fi
				;;
			K) # jump to kext group
				G=2; S=1;;
			T) # jump to Tools group
				G=4; S=1;;
			U) # jump to UEFI quirke
				G=7; S=1;;
			Q) # jump to ACPI quirks
				G=5; S=1;;
			esc|'[')
				esc="true"
				;;
		esac
		if [ "$S" -gt "$(eval echo \$G"$G"_NUM)" ];then
			S=$(eval echo \$G"$G"_NUM)
		fi
		if [ "$S" -eq "0" ];then S=1; fi
		get_res "$G$S"
		set_ROW_COL
		set_color
		select_MSG
	done
	stty echo
	msg "${NC}"
}

#****** Start build ***************
while :
do
	case  "$1" in
	-h) # help
		msg "$(cat "$TOOL_FILES"/help.msg)\n"
		exit 0;;
	-i)
		IGNORE="true"
		shift;;
	-o)
		FINDER="open"
		ex_com="${ex_com}o"
		shift;;
	-q)
		QUIET="-q"
		shift;;
	-u)
		UPDATE="true"
		ex_com="${ex_com}u"
		shift;;
	-v)
		msg "OpenCore-tool version $VER\n"
		exit 0;;
	-T|-t)
		TEXT="true"
		ex_com="${ex_com}t"
		shift;;
	-U)
		UPDATE="stop"
		ex_com="${ex_com}U"
		shift;;
	-V)
		VERBOSE="-v"
		shift;;
	-X)
		if [ -z "$UPDATE" ];then
			msg "Deleting $BASE_DIR/resources ... "
			rm -rf "$BASE_DIR/resources"
			fin
			REMOVE_ALL="true"
		else
			msg "${YEL}WARNING:${NC} not deleting $BASE_DIR/resources since update option selected first\n"
		fi
		shift;;
	--)
		shift; break;;
	esac
done

if [ "$FINDER" = "true" ];then # set defaults for double-click
	ARG1="build"
	ARG2="release"
else
	if [ -n "$1" ]; then
		ARG1="$1"
	fi
	if [ -n "$2" ]; then
		ARG2="$2"
	fi
fi

NOP=""

case $ARG1 in
	b|build) #build first if repo exists, else copy from extras folder
		ARG1="build"
		;;
	c|copy) #copy from extras first if exists, else build from repo
		ARG1="copy"
		;;
	d|debug|r|release)
		msg "${YEL}Usage:${NC} must specify ${U}command${NC} before $ARG1\n"
		exit 1
		;;
	*) #fallthrough - check for options with no command or type
		NOP="true"
esac

if [ -n "$NOP" ];then
	if [ -n "$UPDATE" ]; then # -u option with no following command
		UPDATE="only"; NOP=""
	fi
	if [ -n "$REMOVE_ALL" ]; then #removed resources no command
		exit 0
	fi
	if [ -n "$TEXT" ];then # let -t option use defaults
		NOP=""
	fi
fi

if [ -n "$NOP" ];then
	msg "$(cat "$TOOL_FILES"/usage.msg)\n"
	exit 0
fi

set_build_type "$ARG2"

BUILD_DIR="$BASE_DIR/$AUDK_CONFIG/EFI"
CONFIG_PLIST="$BASE_DIR/$AUDK_CONFIG/config.plist"
if [ -n "$FINDER" ]; then FINDER="$BASE_DIR/$AUDK_CONFIG"; fi


if [ -n "$UPDATE" ]; then
	check_for_updates
	if [ "$UPDATE" != "true" ];then
		msg "${GRN}All resources are up to date.${NC}\n"
		exit 0
	fi
fi

if [ -z "$VERBOSE" ]; then
	exec 6>&1 #start logging
	exec > $LOGFILE
	exec 2>&1
fi

check_requirements
check_config

init_res_array
add_resource "1" "ACPI" "Add" "Path"
add_resource "2" "Kernel" "Add" "BundlePath"
add_resource "3" "UEFI" "Drivers"
add_resource "4" "Misc" "Tools" "Path"
FILE="$CONFIG_PLIST"
USE_VAULT=$(parse "Misc" "Security" "RequireVault")

#swap_res "Lilu.kext" "1" "2"   # place dependencies first # now handled in build func
#swap_res "VirtualSMC.kext" "$P" "2"
#swap_res "Shell.efi" "4" #keep Shell last, uses UDK2018

if [ -n "$TEXT" ]; then
	text_user_interface
	msg "\033[2J\033[H"
fi

if [ -n "$CONFIG_CHANGED" ]; then
	write_new_conf
	command -v "plutil"&&plutil -convert xml1 "$BASE_DIR/Docs/config.plist"
	get_res "06"
	srce="$BASE_DIR/Docs"
	set_res "06"
fi

if [ "$TEXT" = "stop" ];then exit 0;fi

build_resources

set_up_dest_dir
copy_resources

check_if_Sample_plist_updated

if [ "$USE_VAULT" = "true" ];then build_vault; fi

if [ -z "$VERBOSE" ];then
	exec 1>&6 6>&- 2>&1 #stop logfile
fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n"
if [ -n "$CONFIG_CHANGED" ]; then
	msg "${YEL}NOTE:${NC}\tconfig.plist in $BUILD_DIR ${YEL}was changed${NC} by use of the -i/-T options\n"
	msg "\tthis has been done to ensure OC wont fail on boot with this new EFI folder\n"
	msg "\tthe modified config.plist has also been placed in $BASE_DIR/Docs\n"
	msg "\tthe original $AUDK_CONFIG config.plist ${YEL}has not been touched${NC}\n"
fi

if [ -n "$FINDER" ];then open "$FINDER"; fi # open to EFI if -o or dbl-click

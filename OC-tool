#!/bin/sh -e

VER="3.1(040220) last checked with OpenCore version REL-055-2020-02-01"
INI=$(pwd)
cd -- "$(dirname "$0")"

BASE_DIR=$(pwd)

FINDER=""
if [ "$INI" != "$BASE_DIR" ]; then FINDER="true"; fi # double-click from finder

OPTSPEC="dhinoqrstvDTVX"
UNAME=$(uname)
TOOL_FILES="$BASE_DIR/.tool-files"
GIT_JSON="$TOOL_FILES/git_repo.json"
OUTPUT="$BASE_DIR/OUTPUT"
BUILD_DIR="$OUTPUT/EFI"
LOGFILE="$BASE_DIR/tool.log"
INPUT="$BASE_DIR/INPUT/temp"
CONFIG_PLIST="$INPUT/config.plist" # set input plist to temp dir, no mod of original
CONFIG_TXT="$INPUT/config.plist.txt" # used by add_resource()
DOC_DIR="" # repo doc location
HAS_UNZIP=""
SHELL_EFI="Shell_EA4BB293-2D7F-4456-A681-1F22F42CD0BC.efi"

RED='\033[0;31m'; YEL='\033[0;33m'; GRN='\033[0;32m'; BLU='\033[0;34m'
NC='\033[0m'; B='\033[1m'; U='\033[4m' # UO='\033[24m'
INV='\033[7m'

MODE="prebuiltRelease"; TYPE="debug"  # set default to debug version of prebuilt release

EX_COM=$0' -i'; EX_EDIT=$0' -it'; QUIET=""; VERBOSE=""; CONFIG_CHANGED=""
REMOVE_RES=""; BASE_TOOLS=""; TEXT=""; IGNORE=""; UPDATE=""
IGNORE_BOOL=""; USE_VAULT=""; USE_SIG=""; USE_VAULT_NUM=""; USE_SIG_NUM=""

G10_NUM="0"; EDIT_RES_NUM="-1"; LONE=""; HEX_LEN="2"; BIT_NUM=""; BIT_EDIT="0"; BIT_TOGGLE="-1"
DEBUG=""

msg() { #write $1 to screen if not quiet
	if [ -z "$QUIET" ]; then
		printf "%b" "$1" > "$TTY_OUT"
	else
		printf "%b" "$1"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

missing() {
	msg "\n${RED}ERROR:${NC}\t${B}$1${NC} must be installed to continue\n\t$2\n\t$3\n"
	msg "\tor run '${B}.tool-files/get-deps.sh${NC}' which will get dependencies for you\n"
	exit 1
}

check_requirements() { #required commands moved to .tool-files/requirements for portability
	res=""
	while read -r line
	do
		res="$res*$line"
	done < "$TOOL_FILES/requirements"
	res="$res*"
	res=$(echo "$res"|cut -f 2- -d '*')

	until [ -z "$res" ]
	do
		req=$(echo "$res"|cut -f 1 -d ',')
		reqm1=$(echo "$res"|cut -f 2 -d ',')
		reqm2=$(echo "$res"|cut -f 3 -d ',')
		command -v "$req"||missing "$req" "$reqm1" "$reqm2"
		res=$(echo "$res"|cut -f 2- -d '*')
	done
}

check_config() { #config.plist must exist, even with -i option
	if [ ! -f "$BASE_DIR/INPUT/config.plist" ]; then
		msg "\n${RED}ERROR:${NC}\t$BASE_DIR/INPUT/config.plist does not exist\n"
		msg "\tEither - copy a config.plist to the INPUT folder,\n"
		msg "\tor - provide a full path to a config.plist './OC-tool path_to_config'\n"
		msg "\tor - pipe a config.plist into OC-tool 'cat some_config_file | ./OC-tool'\n"
		exit 1
	fi
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR/BOOT"
	mkdir -p "$BUILD_DIR/OC"
	fin
}

update_log() {
	new_hash=$(git rev-parse @|cut -c -7)
	echo "$(date) $1 $2 - $new_hash" >> "$BASE_DIR/update.log"
}

clone() { # will only clone if pkg is not local
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		if [ -z "$UPDATE" ]; then
			msg "Cloning $1 into $pkg_name ... "
			eval git clone "$1" "$pkg_name"
			fin
			cd "$pkg_name"
			update_log "Cloned" "$pkg_name"
			cd ..
		else
			msg "\nCan't clone $pkg_name while using -n option.\n"
			exit 0
		fi
	fi
}

git_failed() {
	msg "\n${RED}ERROR:${NC} failed to retrieve ${YEL}$1${NC} info from git.\n"
	if [ "$1" = "OC-tool" ]; then
		msg "\tThis can be caused by using the Download button on github.com\n"
		msg "\tinstead of using 'git clone https://github.com/rusty-bits/OC-tool'\n"
		msg "\tIf this is the case, try ...\n\n"
		msg "\t'cd' ${YEL}to get to your home directory${NC}\n"
		msg "\t'git clone https://github.com/rusty-bits/OC-tool' ${YEL}to get as a repo${NC}\n"
		msg "\t'cd OC-tool' ${YEL}to enter the newly cloned directory${NC}\n\n"
		msg "\tOtherwise, see tool.log for details.\n"
	else
		msg "\tSee tool.log for details.\n"
	fi
	exit 1
}

check_tool_for_updates() {
	cd "$BASE_DIR"
	msg "\n${GRN}Checking OC-tool for updates${NC} ... "
	git fetch --all -q||git_failed "OC-tool"
	if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ];then
		git pull $VERBOSE -q||git_failed "OC-tool"
		msg "\n\n${YEL}INFO:${NC} OC-tool has been updated, run tool again to continue\n"
		update_log "Updated" "OC-tool"
		exit 2
	fi
	fin
}

check_lilu_for_updates() {
	msg "\n${GRN}Checking Lilu${NC} ... "
	if [ -d "$RES_DIR/Kext_builds/Lilu" ]; then
		cd "$RES_DIR/Kext_builds/Lilu"
		git fetch --all -q||git_failed "Lilu.kext"
		if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ]; then
			new_hash=$(git rev-parse @|cut -c -7)
			msg "\n${GRN}Lilu updated to ${NC}$new_hash\n"
			echo "$(date) Updated Lilu - $new_hash" >> "$BASE_DIR/update.log"
			msg "${YEL}All kexts will be rebuilt${NC}\n"
			rm -rf "$RES_DIR/Kext_builds"
		else
			fin
		fi
	else
		msg "\n${YEL}no existing Lilu found${NC}\n"
		msg "Any existing kexts will be rebuilt to insure they are current\n"
		rm -rf "$RES_DIR/Kext_builds"
	fi
}

check_resources_for_updates() {
	res_updated=""
	msg "\n${GRN}Checking resources folder for updates${NC} ... \n"
	if [ -d "$RES_DIR" ]; then
		for git_dir in $(find "$RES_DIR" -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev)
		do
			cd "$git_dir"
			git fetch --all -q||git_failed "${git_dir##*/}"
			msg "\033[2K\r${git_dir##*/} - "
			if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ]; then
				git pull $VERBOSE -q||git_failed "${git_dir##*/}"
				new_hash=$(git rev-parse @|cut -c -7)
				msg "${GRN}updated to ${NC}$new_hash\n"
				echo "$(date) Updated ${git_dir##*/} - $new_hash" >> "$BASE_DIR/update.log"
				res_updated="true"
			else
				msg "${GRN}OK${NC}"
			fi
		done
		msg "\033[2K\rexisting resources "
		if [ -z "$res_updated" ]; then
			msg "are up to date\n"
		else
			msg "have been updated\n"
		fi
	fi
}

curl_failed() { # is this needed?
	msg "\n${RED}ERROR:${NC}\tdownload failed for $res_name\n"
	msg "\tpossible shasum mismatch\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

unzip_failed() {
	msg "\n${RED}ERROR:$NC\tfailed to unzip $zip_name\n"
	msg "\t${YEL}unzip${NC} command was not found, tried using ${YEL}tar${NC} command\n"
	msg "\twhich is able to unzip on some systems, but apparently not this one\n"
	msg "\t${YEL}unzip${NC} command will need to be installed to continue\n"
	msg "\tand you may need to use the X option at first to clear out unzipped files\n"
	exit 1
}

clone_parent() {
	clone "$git_url"
	srce="$RES_DIR/$pkg_name"
}

clone_child() { # need parent first, then zip source
	path="$git_url"
	git_url=$(grep "/$parent/$MODE/@0/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	temp="$res_name" # hold self
	res_name="$parent"
	clone_parent # temp use parent resources
	git_url="$path"
	res_name="$temp"
}

curl_parent() {
	zip_name="${git_url##*/}"
	zip_dir="$RES_DIR/${res_name%.*}/${zip_name%.*}"
	mkdir -p "$zip_dir"
	cd "$zip_dir"
	if [ ! -e "shasum256" ]; then echo "new" > shasum256; fi
	sha=$(grep "/$res_name/$MODE/@0/$TYPE-sha256 " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$(cat shasum256)" != "$sha" ]; then
		if [ -z "$UPDATE" ]; then
			msg "Downloading $zip_name ... "
			curl -L "$git_url" -o "$zip_name"
			if [ -z "$HAS_SHASUM" ]; then
				shasum -a 256 "$zip_name"|cut -f1 -d ' ' > shasum256
				if [ "$(cat shasum256)" != "$sha" ]; then curl_failed; fi
			fi
			msg "unzipping ... "
			command -v unzip||HAS_UNZIP="false"
			if [ "${zip_name##*.}" = "zip" ]; then
				if [ -z "$HAS_UNZIP" ]; then
					unzip -o "$zip_name"
				else
					tar -xvf "$zip_name"||unzip_failed
				fi
			fi
			fin
			echo "$(date) Downloaded $zip_name - $(printf "%b" "$sha"|cut -c -7)" >> "$BASE_DIR/update.log"
		else
			msg "\nCan't download $zip_name while using -n option.\n"
			exit 0
		fi
	fi
	srce="$(pwd)"
}

curl_child() { # need parent first, then zip source
	path="$git_url"
	git_url=$(grep "/$parent/$MODE/@0/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	temp="$res_name" # hold self
	res_name="$parent"
	curl_parent # temp use parent resources
	git_url="$path"
	res_name="$temp"
	if [ -n "$path" ]; then srce="$srce/$path"; fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
# shellcheck disable=SC1091
	. edksetup.sh
	make -C BaseTools
}

build_failed() { # failed build even after backing up 5 commits
	git checkout master
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

build_shell_tool() { #possible to automate this function?
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/$AUDK_BUILD_DIR/X64"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$SHELL_EFI" ]; then
		rm -rf "$srce"
		clone "https://github.com/acidanthera/audk -b master --depth=1" "UDK"
		cd UDK
		msg "Making audk BaseTools for Shell.efi ... "
		make_base_tools; fin

		msg "Patching audk for Shell.efi ... "
		for p in ../Patches/* ; do
			git apply "$p"||echo "$p ignored, does not apply or alread done"
		done; fin

		msg "Building $AUDK_CONFIG Shell.efi ($SHELL_EFI) ... "
		build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p ShellPkg/ShellPkg.dsc
		fin
		cd ..
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		BASE_TOOLS="" # insure other drivers use non-patched UDK
	fi
}

build_driver() {
	cd "$RES_DIR/UDK"
	clone "$git_url"
	srce="$(pwd)/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		{ [ ! -e "$srce/$res_name" ] && [ "$res_name" != "base" ]; }; then
		rm -rf "$srce" # extreme, but does force whole pkg build if a piece is missing
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then #tools not built yet
				msg "Making base tools ... "
				cd ..
				make_base_tools; fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=1
			while :
			do
				msg "Building $AUDK_CONFIG $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc && break
				if [ "$a" -eq "5" ]; then return 1; fi
				git_sha=$(git rev-parse @|cut -c -7)
				msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
				a=$((a+1))
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

build_kext() {
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	if [ -n "$REMOVE_RES" ];then
		msg "Removing Xcode DerivedData for $pkg_name ... "
		rm -rf "${HOME}"/Library/Developer/Xcode/DerivedData/"${pkg_name}"*
		fin
	fi
	srce="$(pwd)/build/$XCODE_CONFIG"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$res_name" ]; then
		msg "Building $AUDK_CONFIG $pkg_name ... "
		rm -rf Lilu.kext # remove Lilu pkg if it came with repo & link to acidanthera version
		if [ ! -L "Lilu.kext" ]; then ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .; fi
		if [ ! -L "VirtualSMC.kext" ] && [ "$pkg_name" = "AsusSMC" ]; then # AsusSMC needs link to Virtual SMC
			ln -s "$RES_DIR"/Kext_builds/VirtualSMC/build/Debug/VirtualSMC.kext .
		fi
		requiresRes=$(grep "/$res_name/requiresRes " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		if [ -n "$requiresRes" ]; then
			rm -rf "$requiresRes"
			ln -s "$RES_DIR/Kext_builds/$requiresRes" .
		fi
		buildScheme=$(grep "/$res_name/buildScheme " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		a=1
		while :
		do
			if [ -z "$buildScheme" ]; then
				xcodebuild -config "$XCODE_CONFIG" build && break
			else
				xcodebuild -config "$XCODE_CONFIG" -scheme "$buildScheme" -sdk macosx build && break
			fi
			if [ "$a" -eq "5" ]; then return 1; fi
			git_sha=$(git rev-parse @|cut -c -7)
			msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
			git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		done
		if [ "$a" -ne "1" ]; then git checkout master; fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then cp -r build/Products/* build; fi
		fin
	fi
}

missing_iasl() {
	msg "${RED}ERROR:${NC}\t${B}iasl${NC} command is required to compile $res_name\n"
	msg "\tEither:\t* install iasl, or\n\t\t* place $res_name in ${B}extras${NC} directory\n"
	exit 1
}

build_acpi() { # compile .dsl into .aml if user hasn't already
	pkg_name=${res_name%%.*}

	srce=$RES_DIR/$(echo "$git_url"|rev|cut -f2- -d/|rev)
	if [ -e "$srce/$res_name" ];then
		return 0
	elif [ -e "$RES_DIR/$git_url" ];then
		command -v iasl||missing_iasl
		msg "Building $res_name ... "
		iasl "$RES_DIR/$git_url"||return 1
		fin
	else
		return 1
	fi
}

get_res() { # extract resource from psuedo array (needed for POSIX)
	eval enabled="\$res$1"
	res_name=${enabled%%|*}; enabled=${enabled#*|}
	git_url=${enabled%%|*}; enabled=${enabled#*|}
	srce=${enabled%%|*}; enabled=${enabled#*|}
	dest=${enabled%%|*}; enabled=${enabled#*|}
	parent=${enabled%%|*}; enabled=${enabled#*|}
}

set_res() { # encode resource into psuedo array (needed for POSIX)
	eval "res$1='$res_name'\|'$git_url'\|'$srce'\|'$dest'\|'$parent'\|'$enabled'"
}

prepare_resources() {
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	case "$MODE" in
		"latestSource")
			msg "\n${GRN}Building new or updated resources${NC}\n"
			clone "https://github.com/acidanthera/audk" "UDK";;
		"prebuiltRelease")
			HAS_SHASUM=""
			msg "\n${GRN}Downloading/unzipping needed or updated resources${NC}\n"
			command -v shasum||HAS_SHASUM="false"
			if [ -n "$HAS_SHASUM" ]; then
				msg "\n${YEL}NOTICE:${NC}\tshasum command is not available\n"
				msg "\tDownloading will continue, but there is no way to check zip file sums\n"
				msg "\tinstall the shasum command if this is an issue\n\n"
			fi;;
		"prebuiltDaily")
			msg "\n${GRN}Cloning needed or updated resources${NC}\n";;
	esac

	for G in $(seq 0 4) # cycle first 5 groups
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)") # cycle through members
		do
			get_res "$G$S"
			get_edit_res "$enabled"
			if [ "$en" != "-" ]; then
				if [ -z "$srce" ]; then
					case "$MODE" in
						"latestSource")
							case ${res_name##*.} in
							"base"|"efi")
								if [ "$res_name" = "Shell.efi" ]; then #special case
									build_shell_tool||build_failed
								else
									build_driver||build_failed
								fi;;
							"kext")
								if [ "$res_name" = "Lilu.kext" ] && [ "$TYPE" != "debug" ]; then
									set_build_type "debug"
									build_kext||build_failed
									set_build_type "release"
								fi
								build_kext||build_failed;;
							"aml")
								build_acpi||build_failed;;
							esac;;
						"prebuiltRelease")
							case ${res_name##*.} in
							"base")
								;;
							"efi"|"kext"|"aml")
								if [ -n "$parent" ]; then
									curl_child
								else
									curl_parent
								fi;;
							esac;;
						"prebuiltDaily")
							case ${res_name##*.} in
								"efi"|"kext"|"aml")
									if [ -n "$parent" ]; then
										clone_child
									else
										clone_parent
									fi;;
							esac;;
					esac
					set_res "$G$S"
				fi
			fi
		done
	done
	msg "\n"
}

res_not_found() {
	if [ -z "$IGNORE" ]; then
		if [ "$MODE" = "latestSource" ]; then
			msg "\n${RED}ERROR:${NC}\t$1 - resource was not found in $GIT_JSON\n"
		else
			msg "\n${RED}ERROR:${NC}\t$1 - no prebuilt found for $1\n"
		fi
		msg "\t$1 file not found in extras directory\n"
		msg "\tEither place $1 in extras directory to build EFI with $1\n"
		msg "\tor run with -i option to build EFI without $1\n"
		msg "\tfor example, try '$EX_COM'\n"
		exit 1
	else
		msg "${YEL}WARNING:${NC} $1 repo not in $GIT_JSON or extras directory - ${YEL}IGNORING${NC}\n"
		IGNORE="yes"
		CONFIG_CHANGED="-i option" # need to write new config before build
	fi
}

copy_failed() {
	msg "\n\n${RED}ERROR:${NC} Copying $res_name to $dest failed, see $LOGFILE for details.\n"
	exit 1
}

copy_resources() {
	msg "\n${GRN}Moving ${YEL}$MODE${GRN} resources into place${NC}\n"
	IGNORE="" # no more ignoring for you
	for G in $(seq 0 4)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			if [ "$G" -gt "0" ]; then
				get_edit_res "$enabled"
				enabled="false"
				if [ "$en" = "+" ]; then enabled="true"; fi
			fi
			if [ "$enabled" = "true" ];then
				if [ -n "$dest" ]; then
					if [ "$srce" = "unknown" ];then # catch additions from TUI
						res_not_found "$res_name"
					else
						dest_name="$res_name" # workaround for HFSPlus and HfsPlus
						if [ "$dest_name" = "HfsPlus.efi" ]; then res_name="HFSPlus.efi"; fi
						if [ "$dest_name" = "Shell.efi" ] && [ "$MODE" = "latestSource" ]; then res_name="$SHELL_EFI" ;fi
						if [ "$dest_name" = "config.plist" ] && [ -n "$CONFIG_CHANGED" ]; then res_name="modified.config.plist"; fi
						msg "Copying $dest_name to $dest ... "
						mkdir -p "$BUILD_DIR/$dest"
						cp -r "$srce/$res_name" "$BUILD_DIR/$dest/$dest_name"||copy_failed
						fin
					fi
				fi
			fi
		done
	done
}

plist_changed() { # plist from OpenCorePkg has changed, warn user to check their plist
	diff -u "$BASE_DIR/Docs/Sample.plist" "$DOC_DIR/Sample.plist" > "$BASE_DIR/Docs/diff_Sample.txt"||true
	cp "$DOC_DIR/Sample.plist" "$BASE_DIR/Docs/Sample.plist"
	msg "\n${YEL}NOTE:${NC}\tDocs/Sample.plist has changed from last run.\n"
	msg "\tdiffs have been placed in $BASE_DIR/Docs/diff_Sample.plist\n"
	msg "\tyou can see the differences with 'cat ./Docs/diff_Sample.txt'\n"
	msg "\t${YEL}You may want to check for any changes${NC} that could apply to\n"
	msg "\t$filePath\n"
}

check_if_Sample_plist_updated() {
	DOC_DIR="$RES_DIR/UDK/OpenCorePkg/Docs"
	if [ -e "$BASE_DIR/Docs/Sample.plist" ]; then
		cmp --silent "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist||plist_changed
	else
		cp "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	fi
}

vault_failed() {
	msg "${RED}ERROR:${NC} vault build failed, see $LOGFILE for details\n"
	exit 1
}

build_vault() {
	msg "\nBuilding vault files for $BUILD_DIR ... "
	if [ ! -e "$RES_DIR/UDK/OcSupportPkg" ]; then
		mkdir -p "$RES_DIR/UDK/OcSupportPkg"
		cd "$RES_DIR/UDK/OcSupportPkg"
		ocsupporturl=$(grep "/OcSupportPkg/prebuiltRelease/@0/debug " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		curl -L -O "$ocsupporturl"
		ocsupportzip=${ocsupporturl##*/}
		tar xvf "$ocsupportzip"
	fi
	cd "$BUILD_DIR"/OC
	ls vault* 1> /dev/null 2>&1 && rm vault.*
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .||return 1
	if [ "$MODE" = "latestSource" ]; then
		make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool||return 1
	fi
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub||return 1
	str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
	off=$((str+16))
	len=$(wc -c vault.pub|cut -f1 -d 'v'|tr -d ' ')
	dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count="$len" conv=notrunc
	rm vault.pub
	fin
}

find_srce_url() {
	parent=$(grep "/$res_name/parent " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$MODE" = "latestSource" ]; then
		git_url=$(grep "/$res_name/$MODE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		if [ -z "$git_url" ]; then git_url=$(grep "/$parent/latestSource " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"'); fi
	else
		if [ -z "$parent" ]; then
			git_url=$(grep "/$res_name/$MODE/@0/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		else
			git_url=$(grep "/$res_name/path " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		fi
	fi
}

add_res_array() { # add a resource to the psuedo array (needed for POSIX)
	find_srce_url
	if [ -n "$DEBUG" ]; then msg "db - found srce $enabled val $val key $key res_name $res_name\n"; fi
	if [ "$dest" != "OC/ACPI" ];then
		if [ -n "$git_url" ] || [ -n "$parent" ]; then # found repo
			srce=""
		elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ "${key##* }" = "-" ]; then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	else # check extras folder first for ACPI files
		if [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ -n "$git_url" ]; then # found repo
			srce=""
		elif [ "${key##* }" = "-" ];then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	fi
	if [ "$IGNORE" = "yes" ]; then
		srce="unknown"
		IGNORE="true"
		IGNORE_BOOL="yes"
		key="${key% ?} i"
		val="$key"
		set_edit_res "$num"
	fi
	set_res "$G$S"
}

missing_plist_sec() {
	msg "\n${YEL}WARNING:${NC} Missing $1 > $2 section in $filePath\n"
	msg "\tWill continue build, but please note this warning from the Configuration.pdf\n"
	msg "\t${U}Note: Currently most properties try to have defined values even if not specified\n"
	msg "\tin the configuration for safety reasons. This behaviour should not be relied upon, and\n"
	msg "\tall fields must be properly specified in the configuration.${NC}\n"
	num=1
}

add_resource() { #add_resource "Group" "Section" "subsec" "Path"
	G=$1; S=0
	if [ "$G" -lt "5" ]; then
		num=$(grep -c "^$2|*$3|[0-9]*|string|$4| " "$CONFIG_TXT")||missing_plist_sec "$2" "$3"
		for S in $(seq "0" "$((num-1))")
		do
			case "$G" in
				1|2|4)
					res_name=$(grep "^$2|*$3|$S|string|$4| " "$CONFIG_TXT"|cut -f2 -d '"')
					enabled=$(grep "^$2|*$3|$S|bool|Enabled| " "$CONFIG_TXT"|cut -f2 -d '"')
					add_res_array;;
				3)
					res_name=$(grep "^$2|*$3|$S|string|$4| " "$CONFIG_TXT"|cut -f2 -d '"')
					enabled="true"
					add_res_array;;
			esac
		done
	else
# shellcheck disable=SC2013
		for res_name in $(grep "^$2|Quirks|" "$CONFIG_TXT"|cut -f7 -d'|')
		do
			enabled=$(grep "|$res_name| " "$CONFIG_TXT"|cut -f2 -d '"')
			set_res "$G$S"
			S=$((S+1))
		done
		S=$((S-1))
	fi
	eval G"$G"_NUM="$S"
}

init_res_array() { # base-resources moved into .tool-files for portability
	G=0; S="-1"
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=\$line\|true"
		if [ "$MODE" = "latestSource" ]; then
				get_res "0$S"
				if [ "$res_name" = "base" ]; then res_name="$git_url"; fi
				add_res_array
				res_name="base"
				set_res "0$S"
		fi
	done < "$TOOL_FILES/no-pre-base-resources"
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=\$line\|true"
		get_res "0$S"
		add_res_array
	done < "$TOOL_FILES/pre-base-resources"
	G0_NUM=$((S+1))
	eval "res0$G0_NUM=config.plist\|\|'$INPUT'\|OC\|\|true"
}

set_build_type() {
	case $1 in
		d|debug)
			TYPE="debug"; XCODE_CONFIG="Debug";;
		r|release)
			TYPE="release"; XCODE_CONFIG="Release";;
		*)
			msg "Invalid build type selected in set_build_type()\n"
			exit 1;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
}

print_res_array() { # debug aid to list psuedo array
	msg "\033[J\033[0m\n"
	for G in $(seq 0 10)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
				eval line="\$res$G$S"
				msg "$G$S|$line\n"
		done
	done
}

write_new_conf() { # write new config.plist based on changes in psuedo array
	OUT="$BASE_DIR/INPUT/modified.config.plist"
	msg "\033[J\nWriting new config.plist to $OUT ... "
	rm -rf "$OUT"
	num=0; done=""; driver=""
	srch="key"
	get_edit_res "$num"
	while read -r line
	do
		if [ -n "$done" ]; then
			echo "$line" >> "$OUT"
		else
			while [ "$en" = "+" ] || [ "$en" = "-" ] || [ "$en" = "i" ] # find valid G10 key
			do
				if [ "$type" = "string" ]; then # driver handle
					driver="true"; break
				else
					num=$((num+1))
					get_edit_res "$num"
				fi
			done
			[ "$key" = "$val" ] && srch="$type" # found standalone val
			while [ "${line%%>*}" != "<$srch" ] # find plist line with key
			do
				echo "$line" >> "$OUT"
				read -r line
			done
			if [ -z "$driver" ]; then
				echo "<$srch>$key</$srch>" >> "$OUT"
			elif [ "${key##* }" = "+" ]; then
				echo "<$srch>${key% ?}</$srch>" >> "$OUT"
			fi
			driver=""
			if [ "$srch" = "key" ]; then
				case "$type" in
					"bool")
						read -r line
						while [ "${line%/*}" != "<true" ] && [ "${line%/*}" != "<false" ]
						do
							read -r line
						done
						echo "<$val/>" >> "$OUT";;
					"string"|"integer"|"data")
						read -r line
						[ "${line#*</}" = "real>" ] && line="${line%real>}integer>"
						while [ "${line#*</}" != "${type}>" ]
						do
							read -r line
						done
						echo "<${type}>$val</${type}>" >> "$OUT";;
				esac
			else
				srch="key"
			fi
			num=$((num+1))
			if [ "$num" -gt "$G10_NUM" ]; then done="true"; fi
			get_edit_res "$num"
		fi
	done < "$CONFIG_PLIST.mod"
	fin
}

set_ROW_COL(){ # set ROW and COL for TUI mode based on group and section
	case "$G" in
		1|2|3|4)
			ROW=$((S+3))
			COL=$(((G-1)*C+1));;
		5|6|7|8)
			ROW=$((S+BOT+5))
			COL=$(((G-5)*C+1));;
		CH)
			ROW=2
			COL=$(((S-1)*C+1));;
	esac
}

set_text_header() { # eval to avoid unused var in shellcheck
	if [ -n "$DEBUG" ]; then msg "db - in set_text_header\n"; fi
	n=0
	while read -r line
	do
		n=$((n+1))
		eval resCH$n="\$line"
	done < "$TOOL_FILES/text_header.txt"
	eval GCH_NUM="8"
}

set_color() { # set TUI section color based on resource
	case "$val" in
		true)
			color="$GRN"; MSG="+";;
		false)
			color="$RED"; MSG="-";;
		ignored)
			color="$YEL"; MSG="-i";;
		*)
			color="$BLU"; MSG="$val";;
	esac
	if [ "$G" = "CH" ]; then color="$NC"; fi
	if [ "$G" = "3" ]; then color="$color${U}"; fi
}

select_MSG() { # draw highligted resource in TUI
	if [ "$G" -ne "10" ]; then  msg "\033[${ROW};${COL}H$color$INV $res_name $MSG \033[0m"; fi
}

unselect_MSG() { # clear highlighted resource in TUI
	if [ "$G" -ne "10" ]; then  msg "\033[${ROW};${COL}H$color $res_name $MSG "; fi
}

draw_key() {
	if [ "$R" -gt "30" ];then
		msg "$NC\033[$((BOT+KEY+5))H\n"
		msg "$(cat "$TOOL_FILES/key.msg")\n"
	fi
}

draw_screen_header() {
	if [ -n "$DEBUG" ]; then msg "db - in draw_screen_header\n"; fi
	syms="REL"
	[ "$TYPE" = "debug" ] && syms="DBG"
	e_msg="to edit"
	if [ "$G" -eq "10" ]; then e_msg="ret to summary\n\033[K"; fi
	if [ -n "$CONFIG_CHANGED" ]; then
		CC="${RED}${INV}X${NC}${INV}"
	else
		CC="${GRN}${INV} ${NC}${INV}"
	fi
	msg "$NC\033[H${CC}$TUI_MODE${NC}  mode=$GRN$MODE-$syms$NC  IN=${GRN}$filePath${NC} ${U}e${NC} $e_msg\033[K"
}

draw_col_header() {
	if [ -n "$DEBUG" ]; then msg "db - in draw_col_header\n"; fi
	G='CH'; color=${NC}
	for S in $(seq 1 4)
	do
		get_res "$G$S"
		set_ROW_COL
		msg "\033[${ROW};${COL}H$color $res_name "
		get_res "$G$((S+4))"
		ROW=$((ROW+BOT+2))
		msg "\033[${ROW};${COL}H$color $res_name "
	done
}

draw_screen() {
	if [ -n "$DEBUG" ]; then msg "db - in draw_screen\n"; fi
	OLD_G=$G; OLD_S=$S; BOT=0
	R=$(stty size|cut -f1 -d ' '); C=$(stty size|cut -f2 -d ' ')
	C=$((C/4))
	msg "\033[2J\033[H"
	draw_screen_header
	for G in $(seq 1 4)
	do
		if [ -n "$DEBUG" ]; then msg "db - screen loop G=$G\n"; fi
		S="0"
		eval n="\$G${G}_NUM"
		while [ "$S" -le "$n" ]
		do
			get_res "$G$S"
			get_edit_res "$enabled"
			if [ "$en" = "+" ]; then
				val="true"
			elif [ "$en" = "-" ]; then
				val="false"
			elif [ "$en" = "i" ]; then
				val="ignored"
			fi
			res_name="${key% ?}"
			set_ROW_COL
			set_color
			unselect_MSG
			if [ "$BOT" -lt "$S" ];then BOT="$S"; fi
			S=$((S+1))
		done
	done
	KEY=0
	for G in $(seq 5 8)
	do
		eval num="\$G${G}_START"
		num=$((num+1))
		get_edit_res "$num"
		a="$L1"; S=0
		while [ "$a" -eq "$L1" ]
		do
			set_ROW_COL
			res_name="$key"
			enabled="$val"
			set_color
			unselect_MSG
			num=$((num+1)); S=$((S+1))
			get_edit_res "$num"
			if [ -z "$L1" ]; then break; fi
		done
		eval G"${G}"_NUM=\"$((S-1))\"
		if [ "$KEY" -lt "$S" ]; then KEY="$S"; fi
	done
	draw_col_header
	draw_key
	draw_footer
	G=$OLD_G; S=$OLD_S
}

draw_footer() {
	msg "\033[$((R-1));2H$GRN$INV enabled $NC $RED$INV disabled $NC "
	msg "$YEL$INV ignored $NC $BLU$INV integer $NC  q: quit without saving   r: redraw screen"
}

get_CHAR() {
	stty -icanon
	CHAR=$(dd bs=1 count=1 2>/dev/null|od -A n -a|tr -d ' ')
	stty icanon
}

compute_data_vals() {
	case $data_field in
		0|1)
			val="$e_val"
			hex_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '1/1 " %02x"')
			asc_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '"%_p"');;
		2)
			hex_val="$e_val"
			val=$(printf "%b" "$hex_val"|xxd -p -r|base64)
			asc_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '"%_p"');;
		3)
			if [ -z "$asc_touched" ]; then
				asc_val="$e_val"
				val=$(printf "%b" "$asc_val"|base64)
				hex_val=$(printf "%b" "$val"|base64 --decode|hexdump -v -e '1/1 " %02x"')
			fi;;
		esac
}

draw_edit_val() {
	if [ "$key" = "$val" ] && [ -z "$LONE" ]; then
		msg "\033[${S}H${e_text}$e_val${NC}\033[K"
	else
		case "$type" in
			"data")
				compute_data_vals
				msg "\033[${S}H${e_text}$key${NC} | $val |$hex_val | $asc_val |\033[K"
				if [ -n "$e_split" ]; then
					case $data_field in
						1)
							msg "\033[${S}H${e_text}$key${NC} | "
							printf "%.${e_split}s" "$val" > "$TTY_OUT";;
						2)
							msg "\033[${S}H${e_text}$key${NC} | $val |"
							printf "%.${e_split}s" "$hex_val" > "$TTY_OUT";;
						3)
							msg "\033[${S}H${e_text}$key${NC} | $val |$hex_val | "
							printf "%.${e_split}s" "$asc_val" > "$TTY_OUT";;
					esac
				fi;;
			"integer")
				if [ -n "$BIT_NUM" ]; then draw_bit_editor; fi
				case $data_field in
					0|1)
						val="$e_val"
						hex_val=$(echo "obase=16; $val"|bc) # avoid octal
						if [ -z "$hex_val" ]; then hex_val=0; fi
						hex_val=$(printf "%0${HEX_LEN}X" "0x$hex_val");;
					2)
						hex_val="$e_val"
						if [ -z "$e_val" ]; then
							val="0"
						else
							val=$(printf "%d" "0x$e_val") # cant use bc, fails with lowercase hex
						fi;;
				esac
				msg "\033[${S}H${e_text}$key${NC} | $val | 0x$hex_val |\033[K"
				if [ -n "$e_split" ]; then
					case "$data_field" in
						1)
							msg "\033[${S}H${e_text}$key${NC} | "
							printf "%.${e_split}s" "$val" > "$TTY_OUT";;
						2)
							msg "\033[${S}H${e_text}$key${NC} | $val | 0x"
							printf "%.${e_split}s" "$hex_val" > "$TTY_OUT";;
					esac
				fi;;
			*)
				msg "\033[${S}H${e_text}$key${NC} | $e_val |\033[K"
				if [ -n "$e_split" ]; then
					msg "\033[${S}H${e_text}$key${NC} | "
					printf "%.${e_split}s" "$e_val" > "$TTY_OUT"
				fi;;
		esac
	fi
}

draw_edit_key() {
	if [ -n "$DEBUG" ]; then msg "db - in draw_edit_key\n"; fi
	S=$((S+1))
	if [ -z "$type" ]; then
		case "$en" in
			+)
				e_text="${e_text}${GRN}";;
			-)
				e_text="${e_text}${RED}";;
			i)
				e_text="${e_text}${YEL}";;
		esac
		if [ -n "$selected" ]; then e_text="${e_text}${INV}"; selected=""; has_higher_level=""; \
			res_name="$key"; res_num="$num"; res_type="$type"; head_line="$num"; fi
		msg "\033[${S}H${e_text}$key${NC} >  \033[K"
	else
		case $type in
			bool)
				if [ "$e_val" = "true" ]; then
					e_text="${e_text}${GRN}"
				else
					e_text="${e_text}${RED}"
				fi;;
			data)
				e_text="${e_text}${YEL}";;
			integer)
				e_text="${e_text}${BLU}";;
			string)
				if [ "$en" = "+" ]; then
					e_text="${e_text}${GRN}${U}"
				elif [ "$en" = "-" ]; then
					e_text="${e_text}${RED}${U}"
				elif [ "$en" = "i" ]; then
					e_text="${e_text}${YEL}${U}"
				fi;;
		esac
		if [ -n "$selected" ]; then e_text="${e_text}${INV}"; selected=""; has_higher_level="$S"; \
			res_name="$key"; res_num="$num"; res_type="$type"; fi
		draw_edit_val
	fi
}

load_edit_text() {
	[ -n "$DEBUG" ] && msg "\ndb - loading edit text\n"
	num=0; SEC=""; SUB=""
	A0="0"; A1="0"; A2="0"
	G1_NUM=-1; G2_NUM=-1; G3_NUM=-1; G4_NUM=-1
	while read -r line
	do
		eval "res10$num=\$line"
		get_edit_res "$num"
		if [ -n "$DEBUG" ]; then msg "db - loading $type $key\n"; fi
		if [ "$type" = "integer" ]; then
			val=$(printf "%d" "$val") # if hex, make decimal
			set_edit_res "$num"
		fi
		if [ "$key" = "RequireVault" ]; then USE_VAULT_NUM="$num"; fi
		if [ "$key" = "RequireSignature" ]; then USE_SIG_NUM="$num"; fi
		if [ "$key" = "Enabled" ] && [ -n "$IGNORE_BOOL" ]; then
			val="false"
			IGNORE_BOOL=""
			set_edit_res "$num"
		fi
		if [ "$A0" -ne "$L0" ]; then
			SEC="$key"; SUB=""
			A0="$L0"; A1="0"; A2="0"
		elif [ "$A1" -ne "$L1" ]; then
			SUB="$key"; A1="$L1"; A2="0"
			eval "$SEC${SUB}"_START=\"$num\"
		elif [ "$A2" -ne "$L2" ]; then
			A2="$L2"
			G=0
			case "$SEC$SUB" in
				"ACPIAdd")
					G=1; G1_NUM=$((G1_NUM+1)); dest="OC/ACPI";;
				"KernelAdd")
					G=2; G2_NUM=$((G2_NUM+1)); dest="OC/Kexts";;
				"UEFIDrivers")
					G=3; G3_NUM=$((G3_NUM+1)); dest="OC/Drivers";;
				"MiscTools")
					G=4; G4_NUM=$((G4_NUM+1)); dest="OC/Tools";;
			esac
			if [ "$G" -gt "0" ]; then
				res_name="${key% ?}"
				enabled="$num"; S="$((L2-1))"
				if [ -n "$DEBUG" ]; then msg "db - prep $enabled val $val key $key res_name $res_name\n"; fi
				add_res_array
				if [ -n "$DEBUG" ]; then msg "db - added $enabled val $val key $key res_name $res_name\n"; fi
				if [ "$G" -eq "3" ] && [ "${key##* }" != "i" ]; then
					key="$key +"; val="$val +"
					set_edit_res "$num"
				fi
				if [ -n "$DEBUG" ]; then msg "db - enabled $enabled val $val key $key res_name $res_name\n"; fi
			fi
		fi
		num=$((num+1))
		if [ -n "$DEBUG" ]; then msg "db - loaded $type $key\n"; fi
	done < "$INPUT/edit_text.txt"
	num=$((num-1))
	eval G1_START="\$ACPIAdd_START"
	eval G2_START="\$KernelAdd_START"
	eval G3_START="\$UEFIDrivers_START"
	eval G4_START="\$MiscTools_START"
	eval G5_START="\$ACPIQuirks_START"
	eval G6_START="\$KernelQuirks_START"
	eval G7_START="\$UEFIQuirks_START"
	eval G8_START="\$BooterQuirks_START"
	eval G10_NUM="$num"
}

get_edit_res() {
	eval key="\$res10$1"
	L0="${key%%|*}"; key="${key#*|}"
	L1="${key%%|*}"; key="${key#*|}"
	L2="${key%%|*}"; key="${key#*|}"
	L3="${key%%|*}"; key="${key#*|}"
	type="${key%%|*}"; key="${key#*|}"
	val=${key%%|*}; key="${key#*|}"
	en="${key##* }"
}

set_edit_res() {
	eval res10"$1"=\"\$L0\|\$L1\|\$L2\|\$L3\|\$type\|\$val\|\$key\"
}

split_val() {
	val1=$(printf "%.${e_split}b" "$e_val")
	val2="${e_val#$val1}"
}

highlight_type() {
	msg "\033[3H"
	msg "       tab: ${YEL}cycle through types${NC}  "
	if [ "$data_field" -eq "1" ]; then msg "${INV}"; fi
	case "$res_type" in
		"data")
			msg "base64${NC} | ";;
		"integer")
			msg "int${NC} | ";;
	esac
	if [ "$data_field" -eq "2" ]; then msg "${INV}"; fi
	msg "hex${NC} | "
	if [ "$data_field" -eq "3" ]; then msg "${INV}"; fi
	if [ "$res_type" = "data" ]; then msg "ascii${NC}"; fi
	msg "    return: save changes    ${RED}esc esc${NC}: discard changes\033[K"
}

init_bit_editor() {
	BIT_NUM="-1"
	while read -r line
	do
		BIT_NUM=$((BIT_NUM + 1))
		eval BIT${BIT_NUM}=\"\$line\"
	done < "$TOOL_FILES/bit_maps/$res_name"
}

draw_bit_editor() {
	msg "\033[$((S + BIT_NUM + 2))H\033[K"
	bit="$((BIT_NUM - 2))"; bit_total="$val"
	test_bit="31"; test_value="4294967296" # use bit length of 32 when parsing
	while [ "$bit" -ge "0" ]
	do
		eval message=\"\$BIT${bit}\"
# shellcheck disable=SC2154
		bit_value=$(printf "%d" "${message%% *}")
		while [ "$test_value" -ne "$bit_value" ]
		do
			if [ "$test_value" -le "$bit_total" ]; then bit_total=$((bit_total - test_value)); fi
			test_value=$(echo "2^$test_bit"|bc)
			test_bit=$((test_bit-1))
		done
		if [ "$bit_value" -le "$bit_total" ]; then
			if [ "$bit" -eq "$BIT_TOGGLE" ]; then
				BIT_TOGGLE="-1"
				msg "${RED}"
				e_val=$((val - bit_value))
				if [ "$data_field" -eq "2" ]; then e_val=$(echo "obase=16; $e_val"|bc); fi
				e_split=${#e_val}
			else
				msg "${GRN}"
			fi
			bit_total=$((bit_total - bit_value))
		else
			if [ "$bit" -eq "$BIT_TOGGLE" ]; then
				BIT_TOGGLE="-1"
				msg "${GRN}"
				e_val=$((val + bit_value))
				if [ "$data_field" -eq "2" ]; then e_val=$(echo "obase=16; $e_val"|bc); fi
				e_split=${#e_val}
			else
				msg "${RED}"
			fi
		fi
		if [ "$bit" -eq "$BIT_EDIT" ]; then msg "${INV}"; fi
		msg "\033[$((S + bit + 3))H    $message\033[K"
		bit=$((bit - 1))
	done
	msg "${NC}\033[$((S + 1))H\033[K\n  up dn: select bit   space: ${GRN}enable${NC}/${RED}disable${NC} bit\033[K"
}

edit_val() {
	old_val="$val"
	e_split="${#e_val}"
	asc_touched="false"
	if [ -e "$TOOL_FILES/bit_maps/$res_name" ]; then
		read -r line < "$TOOL_FILES/bit_maps/$res_name"
		HEX_LEN=${line%% *}; HEX_LEN=${#HEX_LEN}; HEX_LEN=$((HEX_LEN - 2))
		init_bit_editor
		draw_bit_editor
	fi
	if [ "$type" = "data" ] || [ "$type" = "integer" ]; then
		highlight_type
	fi
	draw_edit_val
	while :
	do
		get_CHAR
		case $CHAR in
			del)
				split_val
				e_val="${val1%?}$val2"
				e_split=$((e_split-1))
				if [ "$data_field" -eq "3" ]; then  asc_touched=""; else asc_touched="false"; fi
				if [ "$e_split" -lt "0" ]; then e_split="0"; fi
				;;
			esc)
				get_CHAR
				case $CHAR in
					"[")
						get_CHAR
						case $CHAR in
							A)
								if [ -n "$BIT_NUM" ]; then
									BIT_EDIT=$((BIT_EDIT - 1))
									if [ "$BIT_EDIT" -lt "0" ]; then BIT_EDIT="0"; fi
								fi;;
							B)
								if [ -n "$BIT_NUM" ]; then
									BIT_EDIT=$((BIT_EDIT + 1))
									if [ "$BIT_EDIT" -gt "$((BIT_NUM-2))" ]; then BIT_EDIT="$((BIT_NUM-2))"; fi
								fi;;
							C)
								e_split=$((e_split+1))
								if [ "$e_split" -gt "${#e_val}" ]; then e_split="${#e_val}"; fi
								;;
							D)
								e_split=$((e_split-1))
								if [ "$e_split" -lt "0" ]; then e_split="0"; fi
								;;
						esac;;
					esc)
						val="$old_val"
						e_val="$val"
						data_field="1"
						BIT_NUM=""; BIT_EDIT="0"
						draw_edit_val
						msg "$(tput civis)"
						break;;
				esac;;
			ht)
				if [ "$type" = "data" ]; then
					case $data_field in
						1)
							e_val="$hex_val"
							data_field="2";;
						2)
							hex_val=$(printf "%b" "$e_val"|xxd -p -r|hexdump -v -e '1/1 " %02x"')
							e_val="$asc_val"
							data_field="3";;
						3)
							e_val="$val"
							data_field="1";;
					esac
					e_split="${#e_val}"
					highlight_type
				elif [ "$type" = "integer" ]; then
					case $data_field in
						1)
							e_val="$hex_val"
							data_field="2";;
						2)
							e_val="$val"
							data_field="1";;
					esac
					e_split="${#e_val}"
					highlight_type
				fi;;
			nl)
				if [ "$type" != "data" ] && [ "$type" != "integer" ]; then val="$e_val"; fi
				if [ -n "$LONE" ]; then
					key="$val"
					LONE=""
				fi
				msg "$(tput civis)"
				CONFIG_CHANGED="-t option"
				BIT_NUM=""; BIT_EDIT="0" # reset bit editing
				draw_screen_header
				break;;
			sp)
				if [ "$type" != "integer" ]; then
					split_val
					e_val="$val1 $val2"
					if [ "$data_field" -eq "3" ]; then asc_touched=""; else asc_touched="false"; fi
					e_split=$((e_split+1))
				else
					[ -n "$BIT_NUM" ] && BIT_TOGGLE="$BIT_EDIT"
				fi;;
			[0-9] )
				split_val
				e_val="$val1$CHAR$val2"
				if [ "$data_field" -eq "3" ]; then asc_touched=""; else asc_touched="false"; fi
				e_split=$((e_split+1));;
			[a-fA-F] )
				if [ "$type" != "integer" ] || [ "$data_field" -eq "2" ]; then
					split_val
					e_val="$val1$CHAR$val2"
					if [ "$data_field" -eq "3" ]; then asc_touched=""; else asc_touched="false"; fi
					e_split=$((e_split+1))
				fi;;
			*)
				if [ "$type" != "integer" ] && [ "$data_field" -ne "2" ]; then
					split_val
					e_val="$val1$CHAR$val2"
					if [ "$data_field" -eq "3" ]; then asc_touched=""; else asc_touched="false"; fi
					e_split=$((e_split+1))
				fi;;
		esac
		draw_edit_val
	done
	HEX_LEN="2"
	EDIT_RES_NUM="-1"
	data_field="0"
	e_split=""
}

draw_plist_footer() {
	msg "\033[$((R-3))H i: info of ${INV}highlighted${NC} item  e: return to summary screen   g: go build new EFI folder\n\033[2K\n"
	msg " $GRN$INV enabled $NC $RED$INV disabled $NC "
	msg "$YEL$INV data $NC $BLU$INV integer $NC $INV string $NC q: quit without saving  s: save and exit\033[K"
}

draw_edit_text() {
	[ -n "$DEBUG" ] && msg "db - in draw_edit_text\n"
	num=0; S=3
	data_field="0"
#	if [ "$moved" = "redraw" ]; then msg "\033[$((R-4))H\033[1J"; fi
	draw_screen_header
	while [ "$num" -le "$G10_NUM" ]
	do
		e_text=""
		get_edit_res "$num"; e_val="$val"
		if [ "$L1" -eq "0" ]; then
			[ "$L0" -eq "$S0" ] && selected="true"
			e_text="$e_text"; draw_edit_key
			[ "$level" -eq "0" ] && LLEN=$L0
		elif [ "$level" -gt "0" ] && [ "$L2" -eq "0" ] && [ "$L0" -eq "$S0" ]; then
			[ "$L1" -eq "$S1" ] && selected="true"
			e_text="    $e_text"; draw_edit_key
			[ "$level" -eq "1" ] && LLEN=$L1
		elif [ "$level" -gt "1" ] && [ "$L3" -eq "0" ] && [ "$L1" -eq "$S1" ] && [ "$L0" -eq "$S0" ]; then
			[ "$L2" -eq "$S2" ] && selected="true"
			e_text="        $e_text"; draw_edit_key
			[ "$level" -eq "2" ] && LLEN=$L2
		elif [ "$level" -gt "2" ] && [ "$L0" -eq "$S0" ] && [ "$L1" -eq "$S1" ] && [ "$L2" -eq "$S2" ]; then
			[ "$L3" -eq "$S3" ] && selected="true"
			e_text="            $e_text"; draw_edit_key
			[ "$level" -eq "3" ] && LLEN=$L3
		fi
		if [ -n "$has_higher_level" ]; then
			if [ "$EDIT_RES_NUM" -eq "$num" ]; then
				data_field="1"
				edit_val
				set_edit_res "$num"
			fi
		fi
	num=$((num+1))
	done
	for n in $(seq $((S+1)) $((R-4)))
	do
		msg "\033[${n}H\033[K"
	done
	draw_plist_footer
	msg "\033[3H"
	case "$res_type" in
		"bool")
			msg "       space: ${GRN}enable${NC}/${RED}disable${NC} value\033[K";;
		"integer")
			highlight_type;;
		"data")
			highlight_type;;
		"string")
			if [ "${res_name##* }" = "+" ] || [ "${res_name##* }" = "-" ]; then
				msg "    space: ${GRN}enable${NC}/${RED}disable${NC} selection\033[K"
			else
				msg "       return: edit string   return: save changes   ${RED}esc esc${NC}: discard changes\033[K"
			fi;;
		*)
			msg "       up dn: select section | ->: expand | <-: collapse"
			if [ "${res_name##* }" = "+" ] || [ "${res_name##* }" = "-" ]; then
				msg "    space: ${GRN}enable${NC}/${RED}disable${NC} selection"
			fi
			if [ "${res_name##* }" = "i" ]; then
				msg "  ${YEL}Disabled by -i option${NC}"
			fi
			msg "\033[K";;
	esac
	msg "\033[${S}H\n"
	res_name="${res_name% ?}"
}

show_description() {
	if [ -n "$DEBUG" ]; then msg "db - in show_description\n"; fi
	DESC=""
	while read -r line
	do
		read -r desc
		if [ "$line" = "$res_name" ];then
			DESC=$desc
			break
		fi
	done < "$TOOL_FILES/description.txt"
	if [ -z "$DESC" ]; then DESC="No description found."; fi
	msg "$NC\033[2K\n$DESC\033[K\n\033[2K"
	moved="redraw"
	if [ -n "$DEBUG" ]; then msg "db - going to select_MSG\n"; fi
	select_MSG
	if [ -n "$DEBUG" ]; then msg "db - going to get_CHAR\n"; fi
	get_CHAR
}

toggle_enabled() {
	if [ "$type" = "" ] || \
	{ [ "$type" = "bool" ] && [ "$key" = "Enabled" ]; }; then
		get_edit_res "$head_line"
		case "$en" in
			"-"|"+")
				temp=${key%?}
				case "${key##* }" in
					"-")
						key="$temp+";;
					"+")
						key="$temp-";;
				esac
				set_edit_res "$head_line"
				num="$head_line"
				while [ "$key" != "Enabled" ]
				do
					num=$((num+1))
					get_edit_res "$num"
				done
				case "$val" in
					true)
						val="false";;
					false)
						val="true";;
				esac
				set_edit_res "$num"
				CONFIG_CHANGED="-t option"
				moved="changed"
				;;
		esac
	elif [ "$type" = "bool" ]; then
		case "$val" in
			true)
				val="false";;
			false)
				val="true";;
		esac
		CONFIG_CHANGED="-t option"
		set_edit_res "$res_num"
		moved="changed"
	elif [ "$en" != "$key" ]; then
		get_edit_res "$res_num"
		if [ "$en" = "+" ]; then
			key="${key% ?} -"
			CONFIG_CHANGED="-t option"
			moved="changed"
		elif [ "$en" = "-" ]; then
			key="${key% ?} +"
			CONFIG_CHANGED="-t option"
			moved="changed"
		fi
		val="$key"
		set_edit_res "$res_num"
	fi
}

text_user_interface() {
	git_url=""; srce=""; dest=""; parent=""
	BOT=0; KEY=0
	CHAR=""; moved=""
	set_text_header
	msg "$(tput smcup)"
	msg "$(tput civis)"
	stty -echo
	G=1; S=0
	level=0; S0=1; S1=0; S2=0; S3=0
	draw_screen
	get_res "$G$S"
	get_edit_res "$enabled"
	if [ "$en" = "+" ]; then
		val="true"
	elif [ "$en" = "-" ]; then
		val="false"
	elif [ "$en" = "i" ]; then
		val="ignored"
	fi
	set_ROW_COL; set_color
	select_MSG
	while [ "$CHAR" != "g" ]
	do
		get_CHAR
		case $CHAR in
			a)
				msg "\nG<$G> S<$S> en<$enabled> key<$key> val<$val> type<$type>\n"
				msg "level<$level> S0 $S0 S1 $S1 S2 $S2 S3 $S3 L0 $L0 L1 $L1 L2 $L2 L3 $L3\n"
				msg "res_num<$res_num> res_name<$res_name> EDIT_RES_NUM$<$EDIT_RES_NUM>\n"
				if [ "$G" -eq "10" ]; then
					get_edit_res "$res_num"
					msg "\nlevel<$level> S0 $S0 S1 $S1 S2 $S2 S3 $S3 L0 $L0 L1 $L1 L2 $L2 L3 $L3\n"
					msg "res_num<$res_num> res_name<$res_name> EDIT_RES_NUM$<$EDIT_RES_NUM>\n"
					msg "\ntype<$type> val<$val> key<$key> en<$en>"
				fi
				;;
			b)
				moved="true"
				eval S="\$G${G}_NUM";;
			e)
				moved="redraw"
				if [ "$TUI_MODE" != "summary" ]; then
					#write_text_config
					TUI_MODE="summary"
					G="$SUMMARY_G"; S="$SUMMARY_S"
					draw_screen
#					G=1; S=0
				else
					TUI_MODE=" plist "
					msg "\033[2H\033[2K"
#					level=0; S0=1; S1=0; S2=0; S3=0
					SUMMARY_G="$G"; SUMMARY_S="$S"
					G="10"
#					S=0
				fi;;
			p) # debug dump array
				stty echo
				msg "${NC}"
				msg "$(tput rmcup)"
				print_res_array
				exit 0;;
			q)
				stty echo
				CHAR='g'
				TEXT="quit";;
			s) # exit loop with 'g' then save Docs/config.plist if changed then stop
				if [ -z "$CONFIG_CHANGED" ]; then CONFIG_CHANGED="save"; fi
				CHAR='g'
				TEXT='stop';;
			*)
				if [ "$G" -lt 10 ]; then
					case "$CHAR" in # key press actions for summary screen
						i)
							show_description
							draw_screen;;
						r)
							draw_screen
							moved="true";;
						A|k) # move up
							moved="true"
							S=$((S-1))
							if [ "$S" -lt "0" ];then
								if [ "$G" -gt "4" ];then
									G=$((G-4))
									eval S="\$G${G}_NUM"
								else
									S=0
								fi
							fi;;
						B|j) # move down
							moved="true"
							S=$((S+1))
							eval len="\$G${G}_NUM"
							if [ "$S" -gt "$len" ];then
								if [ "$G" -lt "5" ];then
									G=$((G+4))
									S=0
								else
									S=$len
								fi
							fi;;
						C|l) # move right
							moved="true"
							G=$((G+1))
							if [ "$G" -eq "5" ]; then G=4; fi
							if [ "$G" -eq "9" ]; then G=8; fi
							;;
						D|h) # move left
							moved="true"
							G=$((G-1))
							if [ "$G" -eq "0" ]; then G=1; fi
							if [ "$G" -eq "4" ]; then G=5; fi
							;;
						sp|nl) # toggle enabled
							unselect_MSG
							moved="changed"
							if [ "$G" = "3" ]; then
								res_num="$enabled"
							elif [ "$G" -lt "5" ]; then
								head_line="$enabled"
							else
								res_num="$num"
							fi
							toggle_enabled
							CONFIG_CHANGED="-t option"
							draw_screen_header;;
						ht)
							G=$((G+1))
							if [ "$G" -gt "8" ]; then G=1; fi
							moved="true";;
					esac
				else
					case "$CHAR" in # key press actions for edit plist screen
						i)
							show_description
							draw_edit_text;;
						r)
							moved="redraw"
							draw_edit_text
							moved="";;
						A|k) # move up
							eval SN="\$S$level"
							SN=$((SN-1))
							if [ "$SN" -lt "1" ]; then
								SN=1
							else
								moved="true"
							fi
							eval S$level=$SN;;
						B|j) # move down
							eval SN="\$S$level"
							SN=$((SN+1))
							if [ "$SN" -gt "$LLEN" ]; then
								SN=$LLEN
							else
								moved="true"
							fi
							eval "S$level=$SN";;
						C|l) # move right
							if [ -z "$has_higher_level" ]; then
								level=$((level+1))
								if [ "$level" -gt "3" ]; then level=3; fi
								eval S$level=1
								moved="redraw"
							fi;;
						D|h) # move left
							if [ "$level" -gt "0" ]; then
								eval S$level=0
								level=$((level-1))
								moved="redraw"
							fi;;
						sp) # only mark CONFIG_CHANGED if change was done  sp|nl
							get_edit_res "$res_num"
							toggle_enabled
							;; # end case sp
						nl|ht)
							get_edit_res "$res_num"
							if [ "$en" = "$key" ]; then
								case $type in
									"string")
										[ "$key" = "$val" ] && LONE="true"
										EDIT_RES_NUM="$res_num"
										moved="changed"
										msg "$(tput cnorm)";;
									"integer"|"data")
										EDIT_RES_NUM="$res_num"
										moved="changed"
										msg "$(tput cnorm)";;
								esac
							fi;;
					esac
				fi
		esac
		eval temp="\$G${G}_NUM"
		if [ "$S" -gt "$temp" ]; then S="$temp"; fi
		if [ "$S" -lt "0" ]; then S=0; fi
		if [ -n "$moved" ]; then
			if [ "$G" -lt "5" ]; then
				unselect_MSG
				get_res "$G$S"
				get_edit_res "$enabled"
				if [ "$en" = "+" ]; then
					val="true"
				elif [ "$en" = "-" ]; then
					val="false"
				elif [ "$en" = "i" ]; then
					val="ignored"
				fi
				set_ROW_COL
				set_color
				select_MSG
			elif [ "$G" -lt "10" ]; then
				unselect_MSG
				eval num="\$G${G}_START"
				num=$((num+S+1))
				get_edit_res "$num"
				res_name="$key"
				set_ROW_COL
				set_color
				select_MSG
			else
				draw_edit_text
			fi
			moved=""
		fi
	done
	stty echo
	msg "${NC}"
}

start_logging() {
	if [ -z "$VERBOSE" ]; then
		exec 6>&1 #start logging
		exec > "$LOGFILE"
		exec 2>&1
	fi
}

stop_logging() {
	if [ -z "$VERBOSE" ]; then exec 1>&6 6>&- 2>&1; fi #stop logfile
}

remove_resource_msg() {
	msg "\n ${RED}***${NC} WARNING: -X option used ${RED}****************************************\n"
	msg " ${RED}*** ${NC}$RES_DIR has been removed\n"
	msg " ${RED}*** ${NC}the -X option is only useful if there is an issue with the\n"
	msg " ${RED}*** ${NC}previously downloaded resources causing problems while building.\n"
	msg " ${RED}*** ${NC}Using it at any other time will only increase bandwith usage and\n"
	msg " ${RED}*** ${NC}compile time, in many cases requiring all tools to be rebuilt.\n"
	msg " ${RED}*********************************************************************${NC}\n"
}

bad_config() {
	if [ -z "$IGNORE" ]; then
		msg "\n${RED}ERROR:${NC} problem found in config.plist file\n"
		msg "\tSee $LOGFILE for details\n\n"
		msg "\tIf you want to try fixing the error with OC-tool, you can use the -it options\n"
		msg "\ttry using '$EX_EDIT'\n\n"
		exit 1
	else
		msg "\n${YEL}WARNING:${NC} problem found in config.plist file --- ${YEL}IGNORING${NC}\n"
		msg "\tMake sure to fix the error before using the EFI\n"
		msg "\t${YEL}###############################################${NC}\n\n"
	fi
}

#****** Start build ***************
if [ -p /dev/stdin ]; then # data was piped, disable TUI and status output
	QUIET="-q" # currently stdin is not a terminal, no output to tty
	TEXT="" # no TUI use either with piped config.plist
	filePath="stdin"
else  #  no input found on stdin
	TTY_OUT=$(tty)
fi
start_logging
if [ -n "$DEBUG" ]; then msg "\ndb - start logging\n"; fi

while getopts "$OPTSPEC" optchar; do
case "${optchar}" in
		d)
			MODE="prebuiltDaily"
			EX_EDIT="${EX_EDIT}d"
			EX_COM="${EX_COM}d";;
		h) # help
			msg "$(cat "$TOOL_FILES"/help.msg)\n"
			exit 0;;
		i)
			IGNORE="true";;
		n)
			UPDATE="false"
			EX_EDIT="${EX_EDIT}n"
			EX_COM="${EX_COM}n";;
		o)
			FINDER="open"
			EX_EDIT="${EX_EDIT}o"
			EX_COM="${EX_COM}o";;
		q)
			QUIET="-q"
			EX_COM="${EX_COM}q";;
		r)
			TYPE="release"
			EX_EDIT="${EX_EDIT}r"
			EX_COM="${EX_COM}r";;
		s)
			MODE="latestSource"
			EX_EDIT="${EX_EDIT}s"
			EX_COM="${EX_COM}s";;
		v)
			VERBOSE="-v"
			EX_COM="${EX_COM}v"
			EX_EDIT="${EX_EDIT}v";;
		t)
			if [ "$filePath" = "stdin" ]; then
				msg "TUI mode unavailable when plist is piped to stdin\n"
			else
				R=$(stty size|cut -f1 -d ' '); C=$(stty size|cut -f2 -d ' ')
				if [ "$C" -lt "90" ] || [ "$R" -lt "40" ]; then
					msg "\n${YEL}NOTICE:${NC} Your terminal size is set to $C x $R\n"
					msg "\tThis is below the suggested miminum size of 90 x 40\n"
					msg "\tfor the TUI mode.  You can resize your terminal or use\n"
					msg "\tthe ${B}-T${NC} option instead of ${B}-t${NC} to override this warning,\n"
					msg "\tbut do note that items on the screen may scroll or be\n"
					msg "\twritten over because of the smaller size\n"
					exit 0
				fi
				TEXT="true"
				TUI_MODE="summary"
			fi
			EX_COM="${EX_COM}t";;
		D) # for when I break stuff
			DEBUG="true";;
		T)
			if [ "$filePath" = "stdin" ]; then
				msg "TUI override is not available when plist is piped to stdin\n"
			else
				TEXT="true"
				TUI_MODE="summary"
			fi
			EX_COM="${EX_COM}T";;
		V)
			msg "OC-tool version $VER\n"
			HAS_NVRAM=""
			command -v nvram 1>/dev/null||HAS_NVRAM="false"
			if [ -z "$HAS_NVRAM" ]; then
				v=$(nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:opencore-version 2>/dev/null || echo "")
				if [ -z "$v" ]; then
					msg "\nNo booted opencore-version found in NVRAM\n"
				else
					msg "\nFound booted ${v#*:}  in NVRAM\n"
				fi
			fi
			exit 0;;
		X)
			REMOVE_RES="true";;
		*)
			msg "$(cat "$TOOL_FILES/usage.msg")\n"
			exit 1;;
	esac
done

RES_DIR="$BASE_DIR/resources/$MODE"
if [ "$MODE" != "latestSource" ] && [ "$UNAME" = "Darwin" ]; then # show start message
	msg "To build from source use ${B}-s${NC} option\n"
fi
msg "For help use '${B}./OC-tool -h${NC}'\n"

if [ -z "$UPDATE" ]; then check_tool_for_updates;fi
rm -rf "$INPUT"
if [ "$filePath" = "stdin" ]; then # get filepath or piped data now that options are processed
	mkdir -p "$INPUT"
	cat > "$CONFIG_PLIST.tmp"
else
	eval filePath="\$$OPTIND"
	if [ -e "$filePath" ]; then
		EX_COM="${EX_COM} ${filePath}"
		EX_EDIT="${EX_EDIT} ${filePath}"
	else
		if [ -n "${filePath}" ]; then
			msg "config.plist file '${filePath}' not found\n"
			msg "$(cat "$TOOL_FILES"/usage.msg)\n"
			exit 1
		else
			check_config
			filePath="$BASE_DIR/INPUT/config.plist"
		fi
	fi
	mkdir -p "$INPUT"
	cp "${filePath}" "$CONFIG_PLIST.tmp"
fi
if [ -n "$DEBUG" ]; then msg "\ndb - filePath $filePath CONFIG_PLIST $CONFIG_PLIST\n"; fi

HAS_PLUTIL=""
command -v "plutil" || HAS_PLUTIL="false"
if [ -z "$HAS_PLUTIL" ]; then
	msg "\n${GRN}Checking config.plist${NC} ... "
	plutil "$CONFIG_PLIST.tmp" || bad_config
	fin
fi

cd "$INPUT"
tr -d '\r' < config.plist.tmp > config.plist # strip CRLF on windows
rm config.plist.tmp
"$TOOL_FILES/parsePlist.sh" "config.plist"

if [ ! -e "edit_subs.txt" ]; then
	msg "\n${RED}ERROR:${NC} ${filePath} does not appear to be an OpenCore plist\n"
	msg "\tIf you don't have an OpenCore plist you can start with the sample provided\n"
	msg "\tby the acidanthera team.  You can copy the sample to your INPUT directory\n"
	msg "\tby using this command, but be aware if a config.plist already exists in\n"
	msg "\tthe INPUT directory it will be replaced.\n\n"
	msg "\t${B}cp ./Docs/Sample.plist ./INPUT/config.plist${NC}\n"
	exit 1
fi

load_edit_text
msg "Using ${filePath}\n"

if [ -n "$DEBUG" ]; then msg "\ndb -loaded edit text\n"; fi
if [ -n "$REMOVE_RES" ]; then rm -rf "$RES_DIR"; fi

set_build_type "$TYPE"

if [ -z "$UPDATE" ]; then
	if [ "$MODE" = "latestSource" ]; then check_lilu_for_updates; fi
	if [ "$MODE" != "prebuiltRelease" ]; then check_resources_for_updates; fi
fi
if [ -n "$REMOVE_RES" ]; then remove_resource_msg; fi #show warning in tool.log also
if [ "$MODE" = "latestSource" ]; then check_requirements; fi
if [ -n "$DEBUG" ]; then msg "\ndb - MODE $MODE TYPE $TYPE UNAME $UNAME\n"; fi

init_res_array

if [ -n "$TEXT" ] && [ -z "$QUIET" ]; then
	msg "\nSwitching to TUI ... "
	text_user_interface
	msg "\033[J\n" # cleanup for TERM types that don't buffer
	msg "$(tput cnorm)"
	msg "$(tput rmcup)"
	msg "${GRN}done in TUI${NC}\n"
fi
if [ "$TEXT" = "quit" ];then # quit without saving changes
	msg "\nOC-tool quit by user.\n"
	exit 0
fi
if [ -n "$USE_VAULT_NUM" ]; then
	get_edit_res "$USE_VAULT_NUM"
	USE_VAULT="$val"
fi
if [ "$USE_VAULT" = "false" ] && [ -n "$USE_SIG" ]; then
	get_edit_res "$USE_SIG_NUM"
	USE_VAULT="$val"
fi

if [ "$MODE" != "latestSource" ] && [ "$UNAME" != "Darwin" ]; then
	if [ "$USE_VAULT" = "true" ]; then
		USE_VAULT="false"
		CONFIG_CHANGED="temp vault disable"
		get_edit_res "$USE_VAULT_NUM"
		val="false"
		set_edit_res "$USE_VAULT_NUM"
		get_edit_res "$USE_SIG_NUM"
		val="false"
		set_edit_res "$USE_SIG_NUM"
		msg "\n${YEL}NOTICE:${NC}\tcurrently unable to build vault files on $UNAME\n"
		msg "\tvault disabled for prebuilts not made on macOS\n"
	fi
fi

if [ -n "$CONFIG_CHANGED" ]; then
	if [ -n "$DEBUG" ]; then msg "\ndb - writing new conf ... done\n"; fi
	write_new_conf
	if [ -z "$HAS_PLUTIL" ]; then
		plutil -convert xml1 "$OUT"||echo "plutil could not convert plist" >> "$INPUT/errors.txt"
	fi
	get_res "0$G0_NUM" # update location for config.plist file
	srce="$BASE_DIR/INPUT"
	set_res "0$G0_NUM"
fi
[ "$TEXT" = "stop" ] && exit 0 # save and quit

prepare_resources
if [ -n "$DEBUG" ]; then msg "\ndb - prepare_resources ... done\n"; fi
set_up_dest_dir
copy_resources

if [ "$MODE" = "latestSource" ]; then check_if_Sample_plist_updated; fi
if [ "$USE_VAULT" = "true" ];then
	build_vault||vault_failed
fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n\n"
if [ -n "$CONFIG_CHANGED" ]; then
	msg "${YEL}NOTE:${NC}\tconfig.plist in $BUILD_DIR ${YEL}was changed${NC} by $CONFIG_CHANGED\n"
	msg "\tthis has been done to ensure OC wont fail on boot with this new EFI folder\n"
	msg "\tthe modified config.plist has been placed in $BASE_DIR/INPUT\n"
	msg "\tthe original $filePath ${YEL}has not been touched${NC}\n\n"
fi
if [ -e "$INPUT/errors.txt" ]; then
	msg "${YEL}WARNING:${NC} errors were found in $filePath\n\n"
	msg "$(cat "$INPUT/errors.txt")"
	msg "\n\nThese errors may need to be addressed before booting\n"
fi
stop_logging

if [ -n "$FINDER" ] && [ "$UNAME" = "Darwin" ];then open "$OUTPUT"; fi # open to EFI if -o or dbl-click

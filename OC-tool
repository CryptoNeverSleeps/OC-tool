#!/bin/sh -e
# shellcheck disable=SC2034

INI=$(pwd)
cd -- "$(dirname "$0")"

BASE_DIR=$(pwd)

if [ "$INI" != "$BASE_DIR" ];then # double-click from finder
	FINDER="true"
else
	FINDER=""
fi

TTY_OUT=$(tty)
UNAME=$(uname)
TOOL_FILES="$BASE_DIR/.tool-files"
GIT_JSON="$TOOL_FILES/git_repo.json"
OUTPUT="$BASE_DIR/OUTPUT"
BUILD_DIR="$OUTPUT/EFI"
LOGFILE="$BASE_DIR/tool.log"
INPUT="$BASE_DIR/INPUT/temp"
CONFIG_PLIST="$INPUT/config.plist"
CONFIG_TXT="$INPUT/config.plist.txt"
DOC_DIR="" # repo doc location
HAS_UNZIP=""

RED='\033[0;31m'; YEL='\033[0;33m'; GRN='\033[0;32m'; BLU='\033[0;34m'
NC='\033[0m'; B='\033[1m'; U='\033[4m'; UO='\033[24m'
INV='\033[7m'
VER="2.3(311219) last checked with OpenCore version DBG-054-2019-12-26"

MODE="prebuiltRelease"; TYPE="debug"  # set default to debug version of prebuilt release

EX_COM=$0' -i'; QUIET=""; VERBOSE=""; CONFIG_CHANGED=""
REMOVE_RES=""; BASE_TOOLS=""; TEXT=""; IGNORE=""; UPDATE=""

EDIT_TEXT_CONFIG=""; G10_NUM="0"

DEBUG=""
optspec="dhinoqrstvDVX"

msg() { #write $1 to screen if not quiet
	if [ -z "$QUIET" ]; then
		printf "%b" "$1" > "$TTY_OUT"
	else
		printf "%b" "$1"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

missing() {
	msg "\n${RED}ERROR:${NC}\t${B}$1${NC} must be installed to continue\n\t$2\n\t$3\n"
	msg "\tor run '${B}.tool-files/get-deps.sh${NC}' which will get dependencies for you\n"
	exit 1
}

check_requirements() { #required commands moved to .tool-files/requirements for portability
	res=""
	while read -r line
	do
		res="$res*$line"
	done < "$TOOL_FILES/requirements"
	res="$res*"
	res=$(echo "$res"|cut -f 2- -d '*')

	until [ -z "$res" ]
	do
		req=$(echo "$res"|cut -f 1 -d ',')
		reqm1=$(echo "$res"|cut -f 2 -d ',')
		reqm2=$(echo "$res"|cut -f 3 -d ',')
		command -v "$req"||missing "$req" "$reqm1" "$reqm2"
		res=$(echo "$res"|cut -f 2- -d '*')
	done
}

check_config() { #config.plist must exist, even with -i option
	if [ ! -f "$BASE_DIR/INPUT/config.plist" ]; then
		msg "\n${RED}ERROR:${NC}\t$BASE_DIR/INPUT/config.plist does not exist\n"
		msg "\tEither - copy a config.plist to the INPUT folder,\n"
		msg "\tor - provide a full path to a config.plist './OC-tool path_to_config'\n"
		msg "\tor - pipe a config.plist into OC-tool 'cat some_config_file' | ./OC-tool'\n"
		exit 1
	fi
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR/BOOT"
	mkdir -p "$BUILD_DIR/OC"
	fin
}

clone() { # will only clone if pkg is not local
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		if [ -z "$UPDATE" ]; then
			msg "Cloning $1 into $pkg_name ... "
			eval git clone "$1" "$pkg_name"
			fin
		else
			msg "\nCan't clone $pkg_name while using -n option.\n"
			exit 0
		fi
	fi
}

check_tool_for_updates() {
	cd "$BASE_DIR"
	msg "\n${GRN}Checking for updates${NC} ... \n"
	msg "OC-tool - " # check OC-tool itself first
	git fetch --all -q
	if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ];then
		git pull $VERBOSE -q
		msg "${GRN}updated${NC}\n\n${YEL}INFO:${NC} OC-tool has been updated, run tool again to continue\n"
		exit 2
	fi
	msg "${GRN}OK${NC}\n"
}

check_lilu_for_updates() {
	res_updated=""
	msg "\n${GRN}Checking existing resources${NC} ... \n"
	if [ -d "$RES_DIR/Kext_builds/Lilu" ]; then
		cd "$RES_DIR/Kext_builds/Lilu"
		git fetch --all -q
		if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ]; then
			new_hash=$(git rev-parse @|cut -c -7)
			msg "${GRN}Lilu updated to ${NC}$new_hash\n"
			echo "$(date) Lilu updated to $new_hash" >> "$BASE_DIR/update.log"
			msg "${YEL}All kexts will be rebuilt${NC}\n"
			rm -rf "$RES_DIR/Kext_builds"
			res_updated="true"
		fi
	fi
}

check_resources_for_updates() {
#		find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev|xargs -I {} git -C {} pull $VERBOSE $QUIET
	if [ -d "$RES_DIR" ]; then
		for git_dir in $(find "$RES_DIR" -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev)
		do
			cd "$git_dir"
			git fetch --all -q
			msg "\033[2K\r${git_dir##*/} - "
			if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ]; then
				git pull $VERBOSE -q
				res_updated="true"
			else
				msg "${GRN}OK${NC}"
			fi
		done
		msg "\033[2K\rexisting resources "
		if [ -z "$res_updated" ]; then
			msg "are up to date\n"
		else
			msg "have been updated\n"
		fi
	fi
}

curl_failed() { # is this needed?
	msg "\n${RED}ERROR:${NC}\tdownload failed for $res_name\n"
	msg "\tpossible shasum mismatch\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

unzip_failed() {
	msg "\n${RED}ERROR:$NC\tfailed to unzip $zip_name\n"
	msg "\t${YEL}unzip${NC} command was not found, tried using ${YEL}tar${NC} command\n"
	msg "\twhich is able to unzip on some systems, but apparently not this one\n"
	msg "\t${YEL}unzip${NC} command will need to be installed to continue\n"
	msg "\tand you may need to use the X option at first to clear out unzipped files\n"
	exit 1
}

curl_parent() {
	zip_name="${git_url##*/}"
	zip_dir="$RES_DIR/${res_name%.*}/${zip_name%.*}"
	mkdir -p "$zip_dir"
	cd "$zip_dir"
	if [ ! -e "shasum256" ]; then echo "new" > shasum256; fi
	sha=$(grep "/$res_name/$MODE/@0/$TYPE-sha256 " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$(cat shasum256)" != "$sha" ]; then
		if [ -z "$UPDATE" ]; then
			msg "Downloading $zip_name ... "
			curl -L "$git_url" -o "$zip_name"
			if [ -z "$HAS_SHASUM" ]; then
				shasum -a 256 "$zip_name"|cut -f1 -d ' ' > shasum256
				if [ "$(cat shasum256)" != "$sha" ]; then curl_failed; fi
			fi
			msg "unzipping ... "
			command -v unzip||HAS_UNZIP="false"
			if [ "${zip_name##*.}" = "zip" ]; then
				if [ -z "$HAS_UNZIP" ]; then
					unzip -o "$zip_name"
				else
					tar -xvf "$zip_name"||unzip_failed
				fi
			fi
			fin
		else
			msg "\nCan't download $zip_name while using -n option.\n"
			exit 0
		fi
	fi
	srce="$(pwd)"
}

curl_child() { # need parent first, then zip source
	path="$git_url"
	git_url=$(grep "/$parent/$MODE/@0/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')

	temp="$res_name" # hold self
	res_name="$parent"

	curl_parent # temp use parent resources

	git_url="$path"
	res_name="$temp"
	if [ -n "$path" ]; then srce="$srce/$path"; fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
# shellcheck disable=SC1091
	. edksetup.sh
	make -C BaseTools
}

build_failed() { # failed build even after backing up 5 commits
	git checkout master
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

build_shell_tool() { #possible to automate this function?
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/$AUDK_BUILD_DIR/X64"
	if [ -f "$srce/Shell.efi" ]; then return 0; fi
	clone "https://github.com/tianocore/edk2 -b UDK2018 --depth=1" "UDK"
	cd UDK
	msg "Making UDK2018 BaseTools ... "
	make_base_tools; fin

	msg "Patching UDK2018 ... "
	for p in ../Patches/* ; do
		git apply "$p"||echo "$p ignored, does not apply or alread done"
	done; fin

	msg "Building $AUDK_CONFIG Shell.efi (OpenCoreShell.efi) ... "
	build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p ShellPkg/ShellPkg.dsc
	fin
}

build_driver() {
	cd "$RES_DIR"/UDK
	clone "$git_url"
	srce="$(pwd)/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		{ [ ! -e "$srce/$res_name" ] && [ "$res_name" != "base" ]; }; then
		rm -rf "$srce" # extreme, but does force whole pkg build if a piece is missing
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then #no need to build again
				msg "Making base tools ... "
				cd ..
				make_base_tools; fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=1
			while :
			do
				msg "Building $AUDK_CONFIG $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc && break
				if [ "$a" -eq "5" ]; then return 1; fi
				git_sha=$(git rev-parse @|cut -c -7)
				msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
				a=$((a+1))
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

build_kext() {
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	if [ -n "$REMOVE_RES" ];then
		msg "Removing Xcode DerivedData for $pkg_name ... "
		rm -rf "${HOME}"/Library/Developer/Xcode/DerivedData/"${pkg_name}"*
		fin
	fi
	srce="$(pwd)/build/$XCODE_CONFIG"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$res_name" ]; then
		msg "Building $AUDK_CONFIG $pkg_name ... "
		rm -rf Lilu.kext # remove Lilu pkg if it came with repo
		if [ ! -L "Lilu.kext" ]; then #link to acidanthera/Lilu debug version
			ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .
		fi
#		if [ ! -L "VirtualSMC.kext" ]; then # AsusSMC needs link to Virtual SMC
#			ln -s "$RES_DIR"/Kext_builds/VirtualSMC/build/Debug/VirtualSMC.kext .
#		fi
		buildScheme=$(grep "/$res_name/buildScheme " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
#		if [ -n "$buildScheme" ]; then buildScheme="-scheme "$buildScheme" -sdk macosx "; fi
		a=1
		while :
		do
			if [ -z "$buildScheme" ]; then
				xcodebuild -config "$XCODE_CONFIG" build && break
			else
				xcodebuild -config "$XCODE_CONFIG" -scheme "$buildScheme" -sdk macosx build && break
			fi
			if [ "$a" -eq "5" ]; then return 1; fi
			git_sha=$(git rev-parse @|cut -c -7)
			msg "\n${YEL}COMMIT $git_sha FAILED:${NC} backing up one commit and trying again\n"
			git checkout "$(git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		done
		if [ "$a" -ne "1" ]; then git checkout master; fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then #copy Products contents back to build level
			cp -r build/Products/* build
		fi
		fin
	fi
}

missing_iasl() {
	msg "${RED}ERROR:${NC}\t${B}iasl${NC} command is required to compile $res_name\n"
	msg "\tEither:\t* install iasl, or\n\t\t* place $res_name in ${B}extras${NC} directory\n"
	exit 1
}

build_acpi() { # compile .dsl into .aml if user hasn't already
	pkg_name=${res_name%%.*}

	srce=$RES_DIR/$(echo "$git_url"|rev|cut -f2- -d/|rev)
	if [ -e "$srce/$res_name" ];then
		return 0
	elif [ -e "$RES_DIR/$git_url" ];then
		command -v iasl||missing_iasl
		msg "Building $res_name ... "
		iasl "$RES_DIR/$git_url"||return 1
		fin
	else
		return 1
	fi
}

get_res() { # extract resource from psuedo array (needed for POSIX)
	eval enabled="\$res$1"
	res_name=${enabled%%,*}; enabled=${enabled#$res_name,}
	git_url=${enabled%%,*}; enabled=${enabled#$git_url,}
	srce=${enabled%%,*}; enabled=${enabled#$srce,}
	dest=${enabled%%,*}; enabled=${enabled#$dest,}
	parent=${enabled%%,*}; enabled=${enabled#$parent,}
}

set_res() { # encode resource into psuedo array (needed for POSIX)
	eval "res$1='$res_name','$git_url','$srce','$dest','$parent','$enabled'"
}

prepare_resources() {
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	if [ "$MODE" = "latestSource" ]; then
		msg "\n${GRN}Building new or updated resources${NC}\n"
		clone "https://github.com/acidanthera/audk" "UDK"

	else
		HAS_SHASUM=""
		msg "\n${GRN}Downloading/unzipping needed or updated resources${NC}\n"
		command -v shasum||HAS_SHASUM="false"
		if [ -n "$HAS_SHASUM" ]; then
			msg "\n${YEL}NOTICE:${NC}\tshasum command is not available\n"
			msg "\tDownloading will continue, but there is no way to check zip file sums\n"
			msg "\tinstall the shasum command if this is an issue\n\n"
		fi
	fi

	for G in $(seq 0 4) # cycle first 5 groups
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)") # cycle through members
		do
			get_res "$G$S"
			if [ "$enabled" != "false" ]; then
				if [ -z "$srce" ]; then
					case "$MODE" in
						"latestSource")
							case ${res_name##*.} in
							"base"|"efi")
								if [ "$res_name" = "Shell.efi" ]; then #special case
									build_shell_tool||build_failed
								else
									build_driver||build_failed
								fi;;
							"kext")
								if [ "$res_name" = "Lilu.kext" ] && [ "$TYPE" != "debug" ]; then
									set_build_type "debug"
									build_kext||build_failed
									set_build_type "release"
								fi
								build_kext||build_failed;;
							"aml")
								build_acpi||build_failed;;
							esac;;
						"prebuiltRelease")
							case ${res_name##*.} in
							"base")
								;;
							"efi"|"kext"|"aml")
								if [ -n "$parent" ]; then
									curl_child
								else
									curl_parent
								fi;;
							esac;;
					esac
					set_res "$G$S"
				fi
			fi
		done
	done
	msg "\n"
}

res_not_found() {
	if [ -z "$IGNORE" ]; then
		if [ "$MODE" = "latestSource" ]; then
			msg "\n${RED}ERROR:${NC}\t$1 - resource was not found in $GIT_JSON\n"
		else
			msg "\n${RED}ERROR:${NC}\t$1 - no prebuilt found for $1\n"
		fi
		msg "\t$1 file not found in extras directory\n"
		msg "\tEither place $1 in extras directory to build EFI with $1\n"
		msg "\tor run with -i option to build EFI without $1\n"
		msg "\tfor example, try '$EX_COM'\n"
		exit 1
	else
		msg "${YEL}WARNING:${NC} $1 repo not in $GIT_JSON or extras directory - ${YEL}IGNORING${NC}\n"
		IGNORE="yes"
		CONFIG_CHANGED="-i option" # need to write new config before build
	fi
}

copy_failed() {
	msg "\n\n${RED}ERROR:${NC} Copying $res_name to $dest failed, see $LOGFILE for details.\n"
	exit 1
}

copy_resources() {
	msg "\n${GRN}Moving ${YEL}$MODE${GRN} resources into place${NC}\n"
	IGNORE="" # no more ignoring for you
	for G in $(seq 0 4)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
			get_res "$G$S"
			if [ "$enabled" = "true" ];then
				if [ -n "$dest" ]; then
					if [ "$srce" = "unknown" ];then # catch additions from TUI
						res_not_found "$res_name"
					else
						dest_name="$res_name" # workaround for HFSPlus and HfsPlus
						if [ "$dest_name" = "HfsPlus.efi" ]; then res_name="HFSPlus.efi"; fi
						msg "Copying $dest_name to $dest ... "
						mkdir -p "$BUILD_DIR/$dest"
						cp -r "$srce/$res_name" "$BUILD_DIR/$dest/$dest_name"||copy_failed
						fin
					fi
				fi
			fi
		done
	done
}

plist_changed() { # plist from OpenCorePkg has changed, warn user to check their plist
	mkdir -p "$BASE_DIR"/Docs
	cp "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	msg "\n${YEL}NOTE:${NC}\tDocs/Sample.plist has changed from last run.\n"
	msg "\tYou may want to check it for any changes that could apply to\n"
	msg "\t$filePath\n"
}


check_if_Sample_plist_updated() {
	DOC_DIR="$RES_DIR/UDK/OpenCorePkg/Docs"
	if [ -e "$BASE_DIR/Docs/Sample.plist" ]; then
		cmp --silent "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist||plist_changed
	else
		cp "$DOC_DIR"/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	fi
}

vault_failed() {
	msg "${RED}ERROR:${NC} vault build failed, see $LOGFILE for details\n"
	exit 1
}

build_vault() {
	msg "\nBuilding vault files for $BUILD_DIR ... "
	if [ ! -e "$RES_DIR/UDK/OcSupportPkg" ]; then
		mkdir -p "$RES_DIR/UDK/OcSupportPkg"
		cd "$RES_DIR/UDK/OcSupportPkg"
		ocsupporturl=$(grep "/OcSupportPkg/prebuiltRelease/@0/debug " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		curl -L -O "$ocsupporturl"
		ocsupportzip=${ocsupporturl##*/}
		tar xvf "$ocsupportzip"
	fi
	cd "$BUILD_DIR"/OC
	if ls vault* 1> /dev/null 2>&1; then
		rm vault.*
	fi
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .||return 1
	if [ "$MODE" = "latestSource" ]; then
		make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool||return 1
	fi
	"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub||return 1
	str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
	off=$((str+16))
	len=$(wc -c vault.pub|cut -f1 -d 'v'|tr -d ' ')
	dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count="$len" conv=notrunc
	rm vault.pub
	fin
}

find_srce_url() {
	parent=$(grep "/$res_name/parent " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
	if [ "$MODE" = "latestSource" ]; then
		git_url=$(grep "/$res_name/$MODE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		if [ -z "$git_url" ]; then
			git_url=$(grep "/$parent/latestSource " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		fi
	else
		if [ -z "$parent" ]; then
			git_url=$(grep "/$res_name/$MODE/@0/$TYPE " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		else
			git_url=$(grep "/$res_name/path " "$TOOL_FILES/git_repo.json.txt"|cut -f2 -d '"')
		fi
	fi
}

add_res_array() { # add a resource to the psuedo array (neede for POSIX)
	find_srce_url
	if [ "$dest" != "OC/ACPI" ];then
		if [ -n "$git_url" ] || [ -n "$parent" ]; then # found repo
			srce=""
		elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ "$enabled" = "false" ]; then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	else # check extras folder first for ACPI files
		if [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ -n "$git_url" ]; then # found repo
			srce=""
		elif [ "$enabled" = "false" ];then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	fi
	if [ "$IGNORE" = "yes" ]; then
		srce="unknown"
		enabled="ignored"
		IGNORE="true"
	fi
	set_res "$G$S"
}

missing_plist_sec() {
	msg "\n${RED}ERROR:${NC}\tMissing $1 > $2 section in $filePath\n"
	msg "\tEvery section is required in the config.plist at this time.\n"
	exit 1
}

add_resource() { #add_resource "Group" "Section" "subsec" "Path"
	G=$1; S=0
	if [ "$G" -lt "5" ]; then
		num=$(grep -c "^$2|*$3|[0-9]*|string|$4| " "$CONFIG_TXT")||missing_plist_sec "$2" "$3"
		for S in $(seq "0" "$((num-1))")
		do
			case "$G" in
				1|2|4)
					res_name=$(grep "^$2|*$3|$S|string|$4| " "$CONFIG_TXT"|cut -f2 -d '"')
					enabled=$(grep "^$2|*$3|$S|bool|Enabled| " "$CONFIG_TXT"|cut -f2 -d '"')
					add_res_array;;
				3)
					res_name=$(grep "^$2|*$3|$S|string|$4| " "$CONFIG_TXT"|cut -f2 -d '"')
					enabled="true"
					add_res_array;;
			esac
		done
	else
# shellcheck disable=SC2013
		for res_name in $(grep "^$2|Quirks|" "$CONFIG_TXT"|cut -f7 -d'|')
		do
			enabled=$(grep "|$res_name| " "$CONFIG_TXT"|cut -f2 -d '"')
			set_res "$G$S"
			S=$((S+1))
		done
		S=$((S-1))
	fi
	eval G"$G"_NUM="$S"
}

init_res_array() { # base-resources moved into .tool-files for portability
	G=0; S="-1"
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=$line,true"
		if [ "$MODE" = "latestSource" ]; then
				get_res "0$S"
				if [ "$res_name" = "base" ]; then res_name="$git_url"; fi
				add_res_array
				res_name="base"
				set_res "0$S"
		fi
	done < "$TOOL_FILES/no-pre-base-resources"
	while read -r line
	do
		S=$((S+1))
		eval "res0$S=$line,true"
		get_res "0$S"
		add_res_array
	done < "$TOOL_FILES/pre-base-resources"
	G0_NUM=$((S+1))
	eval "res0$G0_NUM=config.plist,,'$INPUT',OC,,true"
}

set_build_type() {
	case $1 in
		d|debug)
			TYPE="debug"; XCODE_CONFIG="Debug";;
		r|release)
			TYPE="release"; XCODE_CONFIG="Release";;
		*)
			msg "need to specify ${U}debug${NC} or ${U}release${NC} after ...\n"
			exit 1;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
}

print_res_array() { # debug aid to list psuedo array
	msg "\033[J\033[0m\n"
	for G in $(seq 0 10)
	do
		for S in $(seq 0 "$(eval echo \$G"$G"_NUM)")
		do
			if [ "$G" -lt "10" ]; then
				get_res "$G$S"
				msg "$G$S|$res_name|$git_url|$srce|$dest|$parent|$enabled\n"
			else
				eval line="\$res$G$S"
				msg "$G$S|$line\n"
			fi
		done
	done
}

write_new_array() { # write array section changes to new plist
	while [ "$line" != "</array>" ]
	do
		get_res "$G$S"
		while [ "$line" != "</dict>" ]
		do
			read -r line
			echo "$line" >> "$OUT"
	#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
			if [ "$line" = "<key>Enabled</key>" ];then
				read -r line
				if [ "$enabled" = "ignored" ]; then
					echo "<false/>" >> "$OUT" # ignored resource
				else
					echo "<$enabled/>" >> "$OUT"
				fi
			fi
		done
		S=$((S+1))
		read -r line
		echo "$line" >> "$OUT"
	done
}

write_new_drivers() { # write driver section changes to new plist
	while [ "$line" != "<key>Drivers</key>" ]
	do
		read -r line
		echo "$line" >> "$OUT"
	done
	get_res "$G$S"
	while [ "$line" != "</array>" ]
	do
		read -r line
		if [ "$line" = "<string>$res_name</string>" ];then
			if [ "$enabled" = "true" ];then
				echo "$line" >> "$OUT"
			fi
			S=$((S+1))
			get_res "$G$S"
		else
			echo "$line" >> "$OUT"
		fi
	done
}

write_new_quirks() { # write quirks section changes to new plist
	get_res "$G$S"
	while [ "$line" != "<key>Quirks</key>" ];
	do
		read -r line
		echo "$line" >> "$OUT"
	done
	while [ "$line" != "</dict>" ]
	do
#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
		if [ "$line" = "<key>$res_name</key>" ];then
			read -r line
			case "$enabled" in
				true|false)
					echo "<$enabled/>" >> "$OUT";;
				ignored) # ignored resources
					echo "<false/>" >> "$OUT";;
				[0-9])
					echo "<integer>$enabled</integer>" >> "$OUT";;
				*)
					echo "$line" >> "$OUT";;
			esac
			S=$((S+1))
			get_res "$G$S"
		fi
		read -r line
		echo "$line" >> "$OUT"
	done
}

write_new_conf() { # write new config.plist based on changes in psuedo array
	OUT=$BASE_DIR/Docs/config.plist
	msg "\033[J\nWriting new config.plist to $OUT ... "
	rm -rf "$OUT"
	while read -r line
	do
		echo "$line" >> "$OUT"
#		key=$(echo "$line"|sed -e 's/<[^>]*>//g')
		case "$line" in
			"<key>ACPI</key>")
				G=1; S=0;
				write_new_array
				G=5; S=0;
				write_new_quirks;;
			"<key>Kernel</key>")
				G=2; S=0;
				write_new_array
				G=6; S=0;
				write_new_quirks;;
			"<key>UEFI</key>")
				G=3; S=0;
				write_new_drivers
				G=7; S=0;
				write_new_quirks;;
			"<key>Tools</key>")
				G=4; S=0;
				write_new_array;;
			"<key>Booter</key>")
				G=8; S=0;
				write_new_quirks;;
			"<key>RequireVault</key>"|"<key>RequireSignature</key>")
				read -r line
				echo "<$USE_VAULT/>" >> "$OUT";;
		esac
	done < "$CONFIG_PLIST"
	fin
}

set_ROW_COL(){ # set ROW and COL for TUI mode based on group and section
	case "$G" in
		1|2|3|4)
			ROW=$((S+3))
			COL=$(((G-1)*C+1));;
		5|6|7|8)
			ROW=$((S+BOT+5))
			COL=$(((G-5)*C+1));;
		9)
			ROW=2
			COL=$(((S-1)*C+1));;
	esac
}

set_text_header() {
	eval res91="\\${U}A\\${UO}CPI/\\${U}Q\\${UO}uirks,"
	eval res92="\\${U}K\\${UO}exts/Ker\\${U}n\\${UO}el,"
	eval res93="\\${U}D\\${UO}rivers/\\${U}U\\${UO}EFI,"
	eval res94="\\${U}T\\${UO}ools/\\${U}B\\${UO}ooter,"
	eval G9_NUM="4"
}

set_color() { # set TUI section color based on resource
	case "$enabled" in
		true)
			color="$GRN"; MSG="+";;
		false)
			color="$RED"; MSG="-";;
		ignored)
			color="$YEL"; MSG="-i";;
		*)
			color="$BLU"; MSG="$enabled";;
	esac
	if [ "$G" = "9" ];then color="$NC";fi
}

select_MSG() { # draw highligted resource in TUI
	if [ "$G" -ne "10" ]; then
		msg "\033[${ROW};${COL}H$color$INV $res_name $MSG \033[0m"
	fi
}

unselect_MSG() { # clear highlighted resource in TUI
	if [ "$G" -ne "10" ]; then
		msg "\033[${ROW};${COL}H$color $res_name $MSG "
#		MSG=""
	fi
}

draw_key() {
	if [ "$R" -gt "30" ];then
		msg "$NC\033[$((BOT+KEY+5))H\n"
		msg "$(cat "$TOOL_FILES/key.msg")\n"
	fi
}

draw_screen_header() {
	if [ "$TYPE" = "debug" ]; then
		inc_syms="${GRN}yes${NC}"
	else
		inc_syms="${RED}no${NC}"
	fi
	if [ -n "$CONFIG_CHANGED" ]; then
		CC="${RED}${INV}X${NC}${INV}"
	else
		CC="${GRN}${INV} ${NC}${INV}"
	fi
	msg "$NC\033[H${CC}$TUI_MODE${NC} mode=$GRN$MODE$NC ${U}d${NC}bgSyms=${inc_syms} RequireVault="
	if [ "$USE_VAULT" = "true" ];then
		msg "$GRN"
	else
		msg "$RED"
	fi
	msg "$INV$USE_VAULT$NC\033[K IN=${GRN}$filePath${NC}  \n"
}

draw_col_header() {
	OLD_G=$G; OLD_S=$S
	G=9; color=${NC}
	for S in $(seq 1 4)
	do
		get_res "$G$S"
		set_ROW_COL
		unselect_MSG
	done
	G=$OLD_G; S=$OLD_S
}

draw_screen() {
	OLD_G=$G; OLD_S=$S
	R=$(stty size|cut -f1 -d ' '); C=$(stty size|cut -f2 -d ' ')
	C=$((C/4))
	msg "\033[2J\033[H"
	draw_screen_header
	draw_col_header
	for G in $(seq 1 8)
	do
#		len="$(eval echo \$G"$G"_NUM)"
		eval len="\$G${G}_NUM"
		if [ "$G" -le "4" ];then # BOT = longest group of 1 - 4
			if [ "$BOT" -lt "$len" ];then BOT="$len";fi
		else # KEY = longest group of 5 - 7
			if [ "$KEY" -lt "$len" ]; then KEY="$len";fi
		fi
		for S in $(seq 0 "$len")
		do
			get_res "$G$S"
			set_ROW_COL
			set_color
			unselect_MSG
		done
	done
	draw_key
	draw_footer
	G=$OLD_G; S=$OLD_S
}

draw_footer() {
	msg "\033[$((R-1));2H$GRN$INV enabled $NC $RED$INV disabled $NC "
	msg "$YEL$INV ignored $NC $BLU$INV numeric $NC  q - to quit   r - redraw screen"
}

get_CHAR() {
	stty -icanon
	CHAR=$(dd bs=1 count=1 2>/dev/null|od -A n -a|tr -d ' ')
	stty icanon
}

draw_edit_text() {
	TL0=""; TL1=""; TL2=""
	L0=-1; L1=-1; L2=-1; L3=-1
	LM=""
	if [ "$EDIT_TEXT_CONFIG" = "redraw" ]; then msg "\033[2J"; fi
	draw_screen_header
	current_line=0
	has_higher_level=""
	L1=-1; L2=-1; L3=-1
	msg "\033[3H"
	if [ "$EDIT_TEXT_CONFIG" = "redraw" ]; then
		msg "\033[0J"
		EDIT_TEXT_CONFIG="true"
	fi
	while [ "$current_line" -le "$G10_NUM" ]
	do
		level_flag=">"; sub5=""

		eval line="\$res10$current_line"
		section=${line%%|*}; line="${line#*|}"
		sub1=${line%%|*}; line="${line#*|}"
		sub2=${line%%|*}; line="${line#*|}"
		sub3=${line%%|*}; line="${line#*|}"
		sub4=${line%%|*}; line="${line#*|}"
		type=${line%%|*}; line="${line#*|}"
		key=${line%%|*}; val="${line#*\"}"
		val=${val%\"*}

		if [ "$TL0" != "$section" ]; then # found new section
			TL0="$section"
			TL1=""; TL2=""; TL3=""
			L0=$((L0+1))
			if [ "$S0" -eq "$L0" ]; then msg "${INV}"; fi
#			msg "$L0|$L1|$L2|$L3 $S0|$S1|$S2|$S3 "
			msg "$TL0${NC} $level_flag\n" # $S0 $L0 $S1 $L1 $S2 $L2 $S3 $L3\n" # display level 0
		fi

		if [ "$level" -gt "0" ]; then
			indent="\t"
			for N in $(seq 1 "$level")
			do
				P=$((N-1))
				eval LP="\$L$P"
				eval SP="\$S$P"
					if [ "$LP" -ne "$SP" ]; then break;fi # skip drawing if not selected
					eval SS="\$S$N"
					eval TLL="\$TL$N"
					depth=1; walk=1
					while [ "$depth" -le "$N" ] && [ "$walk" -lt "6" ]
					do
						eval sub="\$sub$walk"
						walk=$((walk+1))
						if [ -n "$sub" ]; then depth=$((depth+1)); fi
					done
					if [ -z "$sub" ]; then
						level_flag="| $val"
						sub="$key"
					fi
					if [ "$TLL" != "$sub" ]; then # found new sub text
						eval "TL$N=\$sub"
						eval "L$N=\$((L$N+1))"
						eval LL="\$L$N"
						if [ "${sub##* }" = "+" ];then msg "${GRN}"; fi
						if [ "${sub##* }" = "-" ];then msg "${RED}"; fi
						if [ "$level_flag" != ">" ]; then
							case $type in
								bool)
									if [ "$val" = "true" ]; then
										msg "${GRN}"
									else
										msg "${RED}"
									fi;;
								data)
									msg "${YEL}"
									;;
								integer)
									msg "${BLU}"
									;;
							esac
						fi
#						msg "$L0|$L1|$L2|$L3 $S0|$S1|$S2|$S3 "
						if [ "$LL" -eq "$SS" ]; then # set opts for selected item
							msg "${INV}"
							if [ "$level_flag" != ">" ]; then has_higher_level="false"; fi
						fi
						msg "$indent$sub${NC} $level_flag\n"
					fi
				indent=$indent"\t"
			done
		fi
		current_line=$((current_line+1)) # line pointer
	done

#	msg "\nL0=$L0 L1=$L1 L2=$L2 L3=$L3 L4=$L4 L5=$L5\n"
#	msg "S0=$S0 S1=$S1 S2=$S2 S3=$S3 S4=$S4 S5=$S5\n"
}

add_text_array() {
	S=0
	while read -r line
	do
		if [ -n "${line%%PLIST|*}" ]; then
			section=${line%%|*}; line="${line#*|}"
			sub1=${line%%|*}; line="${line#*|}"
			sub2=${line%%|*}; line="${line#*|}"
			sub3=${line%%|*}; line="${line#*|}"
			sub4=${line%%|*}; line="${line#*|}"
			type=${line%%|*}; line="${line#*|}"
			key=${line%%|*}; val="${line#*\"}"
			val=${val%\"*}


			line="$section|$sub1|$sub2|$sub3|$sub4|$type|$key| \"$val\""
			eval res10$S="\$line"
			S=$((S+1))
		fi
	done < "$CONFIG_TXT"
	G10_NUM=$((S-1))
}

text_user_interface() {
	git_url=""; srce=""; dest=""; parent=""
	add_resource "5" "ACPI" "Quirks"; add_resource "6" "Kernel" "Quirks"
	add_resource "7" "UEFI" "Quirks"; add_resource "8" "Booter" "Quirks"
	BOT=0; KEY=0
	CHAR=""; moved=""
	set_text_header
	msg "$(tput smcup)"
	stty -echo
	G=1; S=0
	draw_screen
	get_res "$G$S"
	set_ROW_COL; set_color
	select_MSG
	while [ "$CHAR" != "g" ]
	do
		get_CHAR
		moved=""
		case $CHAR in
			b)
#				S=$(eval echo \$G"$G"_NUM);;
				moved="true"
				eval S="\$G${G}_NUM";;
			d)
				if [ "$TYPE" = "release" ];then
					TYPE="debug"
				else
					TYPE="release"
				fi
				draw_screen_header;;
			e)
				moved="true"
				if [ -n "$EDIT_TEXT_CONFIG" ]; then
					#write_text_config
					TUI_MODE="summary"
					EDIT_TEXT_CONFIG=""
					draw_screen
					G=1; S=0
				else
					TUI_MODE=" plist "
					EDIT_TEXT_CONFIG="redraw"
					level=0; S0=0; S1=-1; S2=-1; S3=-1
					add_text_array
					G="10"; S=0
				fi
				;;
			i)
				DESC=""
				while read -r line
				do
					read -r desc
					if [ "$line" = "$res_name" ];then
						DESC=$desc
						break
					fi
				done < "$TOOL_FILES/description.txt"
				if [ -z "$DESC" ];then DESC="No description found.";fi
				msg "$NC\033[2K\n$DESC\033[K\n\033[2K"
				moved="true"
				select_MSG
				get_CHAR
				if [ "$CHAR" = "esc" ];then esc="true"; fi
				draw_screen;;
			n) # jump to kerNel quirks
				moved="true"
				G=6; S=0;;
			p) # debug dump array
				stty echo
				msg "${NC}"
				msg "$(tput rmcup)"
				print_res_array
				exit 0;;
			q)
				stty echo
				CHAR='g'
				TEXT="quit";;
			r)
				if [ "$G" -lt "10" ]; then
					draw_screen
					moved="true"
				else
					draw_edit_text
					moved=""
				fi
				;;
			s) # exit loop with 'g' then save Docs/config.plist if changed then stop
				if [ -z "$CONFIG_CHANGED" ]; then CONFIG_CHANGED="save"; fi
				CHAR='g'
				TEXT='stop';;
			v) # toggle USE_VAULT
				if [ "$USE_VAULT" = "true" ];then
					USE_VAULT="false"
				else
					USE_VAULT="true"
				fi
				CONFIG_CHANGED="-t option"
				draw_screen_header;;
			sp|nl) # only mark CONFIG_CHANGED if change was done
				if [ "$G" -ne "10" ]; then
					unselect_MSG
					moved="changed"
					case "$enabled" in
						true)
							enabled="false";;
						false)
							enabled="true";;
					esac
					CONFIG_CHANGED="-t option"
					set_res "$G$S"
					draw_screen_header
				fi;;
			A|k) # move up
				if [ "$G" -ne "10" ]; then
					moved="true"
					if [ -n "$esc" ] || [ "$CHAR" = "k" ]; then
						S=$((S-1))
						if [ "$S" -lt "0" ];then
							if [ "$G" -gt "4" ];then
								G=$((G-4))
								eval S="\$G${G}_NUM"
							else
								S=0
							fi
						fi
					else # jump to ACPI group
						G=1; S=0
					fi
				else
					eval SN="\$S$level"
					SN=$((SN-1))
					if [ "$SN" -lt "0" ]; then
						SN=0
					else
						moved="true"
					fi
					eval S$level=$SN
				fi
				esc="";;
			B|j) # move down
				if [ "$G" -ne "10" ]; then
					moved="true"
					if [ -n "$esc" ] || [ "$CHAR" = "j" ]; then
						S=$((S+1))
						eval len="\$G${G}_NUM"
						if [ "$S" -gt "$len" ];then
							if [ "$G" -lt "5" ];then
								G=$((G+4))
								S=0
							else
								S=$len
							fi
						fi
					else # jump to Booter quirks
						G=8; S=0
					fi
				else
					eval SN="\$S$level"
					eval LN="\$L$level"
					SN=$((SN+1))
					if [ "$SN" -gt "$LN" ]; then
						SN=$LN
					else
						moved="true"
					fi
					eval "S$level=$SN"
				fi
				esc="";;
			C|l) # move right
				if [ "$G" -ne "10" ]; then
					G=$((G+1))
					if [ "$G" -eq "5" ];then G=4;fi
					if [ "$G" -eq "9" ];then G=8;fi
					moved="true"
				else
					if [ -z "$has_higher_level" ]; then
						level=$((level+1))
						if [ "$level" -gt "5" ]; then level=5; fi
						eval S$level=0
						EDIT_TEXT_CONFIG="redraw"
						moved="true"
					fi
				fi
				esc="";;
			D|h) # move left
				if [ "$G" -ne "10" ]; then
					moved="true"
					if [ -n "$esc" ] || [ "$CHAR" = "h" ]; then
						G=$((G-1))
						if [ "$G" -eq "0" ];then G=1;fi
						if [ "$G" -eq "4" ];then G=5;fi
						esc=""
					else
						G=3; S=0
					fi
				else
					level=$((level-1))
					if [ "$level" -lt "0" ]; then level=0; fi
					EDIT_TEXT_CONFIG="redraw"
					moved="true"
				fi;;
			K) # jump to kext group
				moved="true"
				G=2; S=0;;
			T) # jump to Tools group
				moved="true"
				G=4; S=0;;
			U) # jump to UEFI quirke
				moved="true"
				G=7; S=0;;
			Q) # jump to ACPI quirks
				moved="true"
				G=5; S=0;;
			esc|'[')
				esc="true";;
		esac
#		temp=$(eval echo \$G${G}_NUM)
		eval temp="\$G${G}_NUM"
		if [ "$S" -gt "$temp" ];then
			S="$temp"
		fi
		if [ "$S" -lt "0" ];then S=0; fi
		if [ -n "$moved" ]; then
			if [ "$G" -lt "10" ]; then
				unselect_MSG
				get_res "$G$S"
				set_ROW_COL
				set_color
				select_MSG
			else
				draw_edit_text
			fi
		fi
	done
	stty echo
	msg "${NC}"
}

start_logging() {
	if [ -z "$VERBOSE" ]; then
		exec 6>&1 #start logging
		exec > "$LOGFILE"
		exec 2>&1
	fi
}

stop_logging() {
	if [ -z "$VERBOSE" ];then
		exec 1>&6 6>&- 2>&1 #stop logfile
	fi
}

remove_resource_msg() {
	msg "\n ${RED}***${NC} WARNING: -X option used ${RED}****************************************\n"
	msg " ${RED}*** ${NC}$RES_DIR has been removed\n"
	msg " ${RED}*** ${NC}the -X option is only useful if there is an issue with the\n"
	msg " ${RED}*** ${NC}previously downloaded resources causing problems while building.\n"
	msg " ${RED}*** ${NC}Using it at any other time will only increase bandwith usage and\n"
	msg " ${RED}*** ${NC}compile time, in many cases requiring all tools to be rebuilt.\n"
	msg " ${RED}*********************************************************************${NC}\n"
}

#****** Start build ***************
while getopts "$optspec" optchar; do
case "${optchar}" in
		d)
			MODE="prebuiltDaily"
			EX_COM="${EX_COM}d"
			msg "\n${YEL}$MODE${NC} not implemented yet.\n"
			exit 1;;
		h) # help
			msg "$(cat "$TOOL_FILES"/help.msg)\n"
			exit 0;;
		i)
			IGNORE="true";;
		n)
			UPDATE="false"
			EX_COM="${EX_COM}n";;
		o)
			FINDER="open"
			EX_COM="${EX_COM}o";;
		q)
			QUIET="-q"
			EX_COM="${EX_COM}q";;
		r)
			TYPE="release"
			EX_COM="${EX_COM}r";;
		s)
			MODE="latestSource"
			EX_COM="${EX_COM}s";;
		v)
			VERBOSE="-v"
			EX_COM="${EX_COM}v";;
		t)
			TEXT="true"
			TUI_MODE="summary"
			EX_COM="${EX_COM}t";;
		D) # for when I break stuff
			DEBUG="true";;
		V)
			msg "OC-tool version $VER\n"
			exit 0;;
		X)
			REMOVE_RES="true";;
		*)
			msg "$(cat "$TOOL_FILES/usage.msg")\n"
			exit 1;;
	esac
done
eval filePath="\$$OPTIND"

start_logging
if [ -n "$DEBUG" ]; then msg "\ndb - start logging\n"; fi

RES_DIR="$BASE_DIR/resources/$MODE"

if [ -p /dev/stdin ]; then # data was piped
	mkdir -p "$INPUT"
	cat > "$CONFIG_PLIST"
	QUIET="-q" # currently stdin is not a terminal, no output to tty
	TEXT="" # no TUI use either with piped config.plist
	filePath="stdin"
else  #  no input found on stdin
	if [ -e "$filePath" ]; then
		EX_COM="${EX_COM} ${filePath}"
	else
		if [ -n "${filePath}" ]; then
			msg "config.plist file '${filePath}' not found\n"
			msg "$(cat "$TOOL_FILES"/usage.msg)\n"
			exit 1
		else
			check_config
			filePath="$BASE_DIR/INPUT/config.plist"
		fi
	fi
	mkdir -p "$INPUT"
	cp "${filePath}" "$CONFIG_PLIST"
fi
if [ -n "$DEBUG" ]; then msg "\ndb - filePath $filePath CONFIG_PLIST $CONFIG_PLIST\n"; fi

cd "$INPUT"
cat config.plist|tr -d '\r' > config.plist.tmp # strip CRLF on windows
mv config.plist.tmp config.plist
"$TOOL_FILES/parsePlist.sh" > "$CONFIG_TXT"

if [ "$MODE" != "latestSource" ] && [ "$UNAME" = "Darwin" ]; then # show start message
	msg "To build from source use ${B}-s${NC} option\n"
fi
msg "For help use '${B}./OC-tool -h${NC}'\n\nUsing ${filePath}\n"

if [ -z "$UPDATE" ]; then check_tool_for_updates; fi

if [ -n "$REMOVE_RES" ]; then rm -rf "$RES_DIR"; fi

set_build_type "$TYPE"

if [ "$MODE" = "latestSource" ] && [ -z "$UPDATE" ]; then
	check_lilu_for_updates
	check_resources_for_updates
fi

if [ -n "$REMOVE_RES" ]; then remove_resource_msg; fi #show warning in tool.log also
if [ "$MODE" = "latestSource" ]; then check_requirements; fi

if [ -n "$DEBUG" ]; then msg "\ndb - MODE $MODE TYPE $TYPE UNAME $UNAME\n"; fi
#cd "$TOOL_FILES"
#./parse_json.sh < git_repo.json > git_repo.json.txt

init_res_array
if [ -n "$DEBUG" ]; then msg "\ndb - init_res_array ... done\n"; fi
dest="OC/ACPI"; add_resource "1" "ACPI" "Add" "Path"
if [ -n "$DEBUG" ]; then msg "\ndb - add ACPI ... done\n"; fi
dest="OC/Kexts"; add_resource "2" "Kernel" "Add" "BundlePath"
if [ -n "$DEBUG" ]; then msg "\ndb - add Kernel ... done\n"; fi
dest="OC/Drivers"; add_resource "3" "UEFI" "Drivers"
if [ -n "$DEBUG" ]; then msg "\ndb - add Drivers ... done\n"; fi
dest="OC/Tools"; add_resource "4" "Misc" "Tools" "Path"
if [ -n "$DEBUG" ]; then msg "\ndb - add Tools ... done\n"; fi

USE_VAULT=$(grep "|bool|RequireVault|" "$CONFIG_TXT"|cut -f2 -d '"')

if [ -n "$TEXT" ] && [ -z "$QUIET" ]; then
	msg "\nSwitching to TUI ... "
	text_user_interface
	msg "\033[J\n" # cleanup for TERM types that don't buffer
	msg "$(tput rmcup)"
	msg "${GRN}done in TUI${NC}\n"
fi

if [ "$TEXT" = "quit" ];then # quit without saving changes
	msg "\nOC-tool quit by user.\n"
	exit 0
fi

if [ "$MODE" != "latestSource" ] && [ "$UNAME" != "Darwin" ]; then
	if [ "$USE_VAULT" = "true" ]; then
		USE_VAULT="false"
		CONFIG_CHANGED="temp vault disable"
		msg "\n${YEL}NOTICE:${NC}\tcurrently unable to build vault files on $UNAME\n"
		msg "\tvault disabled for prebuilts not made on macOS\n"
	fi
fi

if [ -n "$CONFIG_CHANGED" ]; then
	write_new_conf
	command -v "plutil"&&plutil -convert xml1 "$BASE_DIR/Docs/config.plist"
	get_res "0$G0_NUM" # update location for config.plist file
	srce="$BASE_DIR/Docs"
	set_res "0$G0_NUM"
fi

if [ "$TEXT" = "stop" ];then exit 0;fi # save and quit

prepare_resources
if [ -n "$DEBUG" ]; then msg "\ndb - prepare_resources ... done\n"; fi
set_up_dest_dir
copy_resources

if [ "$MODE" = "latestSource" ];then check_if_Sample_plist_updated; fi

if [ "$USE_VAULT" = "true" ];then
	build_vault||vault_failed
fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n\n"
if [ -n "$CONFIG_CHANGED" ]; then
	msg "${YEL}NOTE:${NC}\tconfig.plist in $BUILD_DIR ${YEL}was changed${NC} by $CONFIG_CHANGED\n"
	msg "\tthis has been done to ensure OC wont fail on boot with this new EFI folder\n"
	msg "\tthe modified config.plist has also been placed in $BASE_DIR/Docs\n"
	msg "\tthe original $filePath ${YEL}has not been touched${NC}\n\n"
fi

stop_logging

if [ -n "$FINDER" ] && [ "$UNAME" = "Darwin" ];then open "$OUTPUT"; fi # open to EFI if -o or dbl-click

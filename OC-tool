#!/bin/sh -e

BASE_DIR=$(pwd)
FINDER=""
RES_DIR="$BASE_DIR/resources"
TOOL_FILES="$BASE_DIR/.tool-files"
LOGFILE="tool.log"
RED='\033[0;31m'; YEL='\033[1;33m'; GRN='\033[0;32m'
NC='\033[0m' # No Color
B='\033[1m'; U='\033[4m'
VER="1.5pt(0921) last checked with OpenCore version REL-051-2019-09-19"
COPY=""; USE_EXTRAS=""
QUIET=""; VERBOSE=""
UPDATE=""
REMOVE_ALL=""
BASE_TOOLS=""
TEXT=""
G0_NUM=4; G1_NUM=0; G2_NUM=0; G3_NUM=0; G4_NUM=0

eval set -- "$(getopt hoquvTUVX "$@")"

msg() {
	if [ -z "$QUIET" ]; then
		echo "$1\c" >"$(tty)"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

missing() {
	msg "\n${RED}ERROR:${NC} $1 must be installed to continue\n"
	exit 1
}

check_requirements() {
	res=""
	while read -r line
	do
		res="$res $line"
	done < "$TOOL_FILES/requirements"
	for req in $res #why can't this be done in the read loop?
	do
		command -v "$req"||missing "$req"
	done
}

check_config() {
	if [ ! -f "$BASE_DIR/$CONFIG_PLIST" ]; then
		msg "\n${RED}ERROR:${NC} $BASE_DIR/$CONFIG_PLIST does not exist\n\nPlease create this file and run the tool again.\n"
		exit 1
	fi
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR/BOOT"
	mkdir -p "$BUILD_DIR/OC"
	fin
}

init_res_array() {
	G=0
	S=0
	while read -r line
	do
		S=$((S+1))
		eval "res$G$S=$line"
	done < "$TOOL_FILES/base-resources"
	G0_NUM=$S
}

#swap_res() {
#	S=1
#	while [ "$S" -le "$(eval echo \$G${G}_NUM)" ]
#	do
#		get_res "$2$S"
#		if [ "$res_name" = "$1" ]; then
#			eval temp_res=\$res"$2$S"
#			eval res$2$S=\$res"$2$S"
#			eval res$2$S="\$temp_res"
#			unset temp_res
#			return 1
#		fi
#		S=$((S+1))
#	done
#}

#swap_res_array() {
#	base_num=$((base_num+1))
#	swap_res "Lilu.kext" "2"||base_num=$((base_num+1)) #keep Lilu first, must compile before other kexts
#	swap_res "VirtualSMC.kext" "2"||base_num=$((base_num+1)) #VirtualSMC must compile before AsusSMC
#	swap_res "Shell.efi" "4"||echo "shell swapped to end" #keep Shell last, uses UDK2018
#}

clone() {
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		msg "Cloning $1 into $pkg_name ... "
		eval git clone "$1" "$pkg_name"
		fin
	fi
}

check_for_updates() {
	UPDATED=""
	msg "\n${GRN}Checking for updates${NC} ... \n"
	cd "$BASE_DIR"
	git fetch --all $VERBOSE $QUIET
	if [ "$(git rev-parse "@")" != "$(git rev-parse "@{u}")" ];then
		git pull $VERBOSE $QUIET
		msg "${YEL}INFO:${NC} OpenCore-tool has been updated, run tool again to continue\n"
		exit 0
	fi
#		find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev|xargs -I {} git -C {} pull $VERBOSE $QUIET
	if [ -d "$RES_DIR" ]; then
		cd "$RES_DIR" # now check all other resources
		for git_dir in $(find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev)
		do
			git -C "$git_dir" fetch --all $VERBOSE $QUIET
			if [ "$(git -C "$git_dir" rev-parse @)" != "$(git -C "$git_dir" rev-parse "@{u}")" ];then
				msg "\ngit_dir is $git_dir -\n"
				git -C "$git_dir" pull $VERBOSE $QUIET
				UPDATED="changed"
			fi
		done
	fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
# shellcheck disable=SC1091
	. edksetup.sh
	make -C BaseTools
}

build_shell_tool() { #possible to automate this function?
	set_build_type "$build_type"
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/$AUDK_BUILD_DIR/X64"
	if [ -f "$srce/Shell.efi" ]; then return 0; fi
	clone "https://github.com/tianocore/edk2 -b UDK2018 --depth=1" "UDK"
	cd UDK
	msg "Making UDK2018 BaseTools ... "
	make_base_tools; fin

	msg "Patching UDK2018 ... "
	for p in ../Patches/* ; do
		git apply "$p"||echo "$p ignored, does not apply or alread done"
	done; fin

	msg "Building $AUDK_CONFIG Shell.efi (OpenCoreShell.efi) ... "
	build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p ShellPkg/ShellPkg.dsc
	fin
}

build_failed() {
	git checkout master
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

build_kext() {
	set_build_type "$build_type"
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/build/$XCODE_CONFIG"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$res_name" ]; then
		msg "Building $AUDK_CONFIG $pkg_name ... "
		rm -rf Lilu.kext # remove Lilu pkg if it came with repo
		if [ ! -L "Lilu.kext" ]; then #link to acidanthera/Lilu debug version
			ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .
		fi
		if [ ! -L "VirtualSMC.kext" ]; then # AsusSMC needs link to Virtual SMC
			ln -s "$RES_DIR"/Kext_builds/VirtualSMC/build/Debug/VirtualSMC.kext .
		fi
		a=1
		while :
		do
		xcodebuild -config "$XCODE_CONFIG" build && break
			if [ "$a" -eq "6" ]; then return 1; fi
			msg "\n${YEL}$pkg_name TRY $a FAILED:${NC} backing up one commit and trying again\n"
			git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		done
		if [ "$a" -ne "1" ]; then git checkout master; fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then #copy Products contents back to build level
			cp -r build/Products/* build
		fi
		fin
	fi
}

build_driver() {
	set_build_type "$build_type"
	cd "$RES_DIR"/UDK
	clone "$git_url"
	srce="$(pwd)/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		{ [ ! -e "$srce/$res_name" ] && [ "$res_name" != "base" ]; }; then
		rm -rf "$srce" # extreme, but does force whole pkg build if a piece is missing
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then #no need to build again
				msg "Making base tools ... "
				cd ..
				make_base_tools; fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=1
			while :
			do
				msg "Building $AUDK_CONFIG $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc && break
				if [ "$a" -eq "5" ]; then return 1; fi
				msg "\n${YEL}$pkg_name TRY $a FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
				a=$((a+1))
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

missing_iasl() {
	msg "${RED}ERROR:${NC}\t${B}iasl${NC} command is required to compile $res_name\n\tEither:\t* install iasl, or\n\t\t* place $res_name in ${B}extras${NC} directory\n"
	exit 1
}

build_acpi() {
	pkg_name=$(echo "$res_name"|cut -f1 -d.)
	srce=$RES_DIR/$(echo "$git_url"|rev|cut -f2- -d/|rev)
	if [ -e "$srce/$res_name" ];then
		return 0
	elif [ -e "$RES_DIR/$git_url" ];then
		command -v iasl||missing_iasl
		msg "Building $res_name ... "
		iasl "$RES_DIR/$git_url"||return 1
		fin
	else
		return 1
	fi
}

get_res() {
	res=$(eval echo "\$res$1")
	res_name=$(echo "$res"|cut -f1 -d,)
	git_url=$(echo "$res"|cut -f2 -d,)
	build_type=$(echo "$res"|cut -f3 -d,)
	srce=$(echo "$res"|cut -f4 -d,)
	dest=$(echo "$res"|cut -f5 -d,)
	Enabled=${res##*,}
}

set_res() {
	eval "res$1=$res_name,$git_url,$build_type,$srce,$dest,$Enabled"
}

build_resources() {
	msg "\n${GRN}Building needed or updated resources${NC}\n"
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	clone "https://github.com/acidanthera/audk" "UDK"
	G=0
	while [ "$G" -lt "5" ]
	do
		S=1
		while [ "$S" -le "$(eval echo \$G${G}_NUM)" ]
		do
			get_res "$G$S"
			if [ "$Enabled" != "false" ];then
				if [ -z "$srce" ]; then
					case ${res_name##*.} in
					"base" | "efi" )
						if [ "$res_name" = "Shell.efi" ]; then #special case
							build_shell_tool||build_failed
						else
							build_driver||build_failed
						fi
						set_res "$G$S"
						;;
					"kext" )
						build_kext||build_failed
						set_res "$G$S"
						;;
					"aml" )
						build_acpi||build_failed
						set_res "$G$S"
						;;
					esac
				fi
			fi
			S=$((S+1))
		done
		G=$((G+1))
	done
	msg "\n"
}

res_not_found() {
	msg "\n${RED}ERROR:${NC}\t$1 - resource was not found in tool-files/repo.plist\n\t$1 file not found in extras directory\n\tPlace $1 file in extras directory to continue\n"
	exit 1
}

copy_resources() {
	msg "\n${GRN}Moving ${YEL}$ARG2${GRN} resources into place${NC}\n"
	G=0
	while [ "$G" -lt "5" ]
	do
		S=1
		while [ "$S" -le "$(eval echo \$G${G}_NUM)" ]
		do
			get_res "$G$S"
			if [ "$Enabled" != "false" ];then
				if [ -n "$dest" ]; then
					if [ "$srce" = "unknown" ];then res_not_found "$res_name";fi
					msg "Copying $res_name to $dest ... "
					mkdir -p "$BUILD_DIR/$dest"
					cp -r "$srce/$res_name" "$BUILD_DIR/$dest"
					fin
				fi
			fi
			S=$((S+1))
		done
		G=$((G+1))
	done
}

config_changed() {
	mkdir -p "$BASE_DIR"/Docs
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist
	msg "\n${YEL}WARNING:${NC} Sample$1.plist has been updated\n${YEL}!!!${NC} Make sure $BASE_DIR/$CONFIG_PLIST is up to date${NC}.\nRun the tool again if you make any changes.\n"
	cfg_ok="false"
}


check_if_Sample_plist_updated() {
	cfg_ok=""
	msg "\nChecking if Sample.plist or SampleFull.plist format has changed ... "
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist||config_changed
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist||config_changed "Full"
	if [ -z "$cfg_ok" ]; then fin; fi
}

parse() {
	a=0
	in_loop=0
	while read -r ONE
	do
		case "$1" in
			'')
				if [ "$a" -eq "0" ]; then
					case "$ONE" in
						"<true/>")
							echo true;;
						"<false/>")
							echo false;;
						*)
							echo "$ONE"|sed -e 's/<[^>]*>//g';;
					esac
					return
				else
					a=$((a-1))
				fi;;
			*[!0-9]*)
				case "$ONE" in
					"<key>$1</key>")
						if [ "$a" -eq "0" ];then
							shift
						else
							a=$((a-1))
						fi;;
					"</array>")
						if [ "$in_loop" = "1" ];then return; fi
						;;
				esac;;
			*)
				a=$1
				in_loop=1
				shift;;
		esac
	done < "$FILE"
}

build_vault() {
	FILE="$BASE_DIR/$CONFIG_PLIST"
	use_vault=$(parse "Misc" "Security" "RequireVault")
	if [ "$use_vault" = "true" ]; then
		msg "\nBuilding vault files for $BUILD_DIR ... "
		cd "$BUILD_DIR"/OC
		if ls vault* 1> /dev/null 2>&1; then
			rm vault.*
		fi
		"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .
		make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool
		"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub
		str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
		off=$((str+16))
		dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count=520 conv=notrunc
		rm vault.pub
		fin
	fi
}

add_res_array() {
	FILE="$TOOL_FILES/repo.plist"
	git_url=$(parse "$res_name")
	if [ -z "$COPY" ] && [ -z "$USE_EXTRAS" ];then
		if [ -n "$git_url" ]; then
			srce=""
		elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ "$Enabled" = "false" ]; then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
	else # copy mode, check extras folder first
		if [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ -n "$git_url" ]; then
			srce=""
		elif [ "$Enabled" = "false" ];then
			srce="unknown"
		else
			res_not_found "$res_name"
		fi
		USE_EXTRAS=""
	fi
	set_res "$G$S"
}

add_drivers_res_list() {
	i=0
	G=3
	S=1
	res_name="start"
	until [ -z "$res_name" ]
	do
		FILE="$BASE_DIR/$CONFIG_PLIST"
		res_name=$(parse "UEFI" "Drivers" "$i")
		Enabled="true"
		if [ -n "$res_name" ]; then
			dest="/OC/Drivers"
			build_type=$ARG2
			add_res_array
			S=$((S+1))
		fi
		i=$((i+1))
	done
	G3_NUM=$((S-1))
}

add_kexts_res_list() {
	i=0
	G=2
	S=1
	res_name="start"
	until [ -z "$res_name" ]
	do
		FILE="$BASE_DIR/$CONFIG_PLIST"
		res_name=$(parse "Kernel" "Add" "$i" "BundlePath")
		if [ "$ARG2" != "debug" ];then #need DEBUG dependencies
			if [ "$res_name" = "Lilu.kext" ] || [ "$res_name" = "VirtualSMC.kext" ];then
				Enabled="dep"
				build_type="debug"
				dest=""
				add_res_array
				S=$((S+1))
				KEXTS=$((KEXTS+1))
			fi
		fi
		FILE="$BASE_DIR/$CONFIG_PLIST"
		Enabled=$(parse "Kernel" "Add" "$i" "Enabled")
		if [ -n "$Enabled" ]; then
			build_type=$ARG2
			dest="OC/Kexts"
			add_res_array
			S=$((S+1))
		fi
		i=$((i+1))
	done
	G2_NUM=$((S-1))
}

add_tools_res_list() {
	i=0
	G=4
	S=1
	res_name="start"
	until [ -z "$res_name" ]
	do
		FILE="$BASE_DIR/$CONFIG_PLIST"
		Enabled=$(parse "Misc" "Tools" "$i" "Enabled")
		res_name=$(parse "Misc" "Tools" "$i" "Path")
		if [ -n "$Enabled" ]; then
			dest="OC/Tools"
			build_type=$ARG2
			add_res_array
			S=$((S+1))
		fi
		i=$((i+1))
	done
	G4_NUM=$((S-1))
}

add_acpi_res_list() {
	i=0
	G=1
	S=1
	res_name="start"
	until [ -z "$res_name" ]
	do
		FILE="$BASE_DIR/$CONFIG_PLIST"
		Enabled=$(parse "ACPI" "Add" "$i" "Enabled")
		res_name=$(parse "ACPI" "Add" "$i" "Path")
		if [ -n "$Enabled" ]; then
			dest="OC/ACPI"
			build_type=$ARG2
			USE_EXTRAS="true"
			add_res_array
			S=$((S+1))
		fi
		i=$((i+1))
	done
	G1_NUM=$((S-1))
}

set_build_type() {
	if [ -z "$build_type" ]; then build_type=$ARG2; fi;
	case $build_type in
		d|debug)
			ARG2="debug"
			XCODE_CONFIG="Debug"
			;;
		r|release)
			ARG2="release"
			XCODE_CONFIG="Release"
			;;
		*)
			msg "need to specify ${U}debug${NC} or ${U}release${NC} after $ARG1 command\n"
			exit 1
			;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
}

print_res_array() {
	G=0
	while [ "$G" -lt "10" ]
	do
		S=1
		while [ "$S" -le "$(eval echo \$G${G}_NUM)" ]
		do
			get_res "$G$S"
			msg "$G$S $res_name $git_url $srce $dest $Enabled\n"
			S=$((S+1))
		done
		G=$((G+1))
	done
}

add_quirks() {
	i=0
	G="$2"
	S=1
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(parse "$1" "Quirks" "$i")
		if [ -n "$res_name" ];then
			Enabled=$(parse "$1" "Quirks" "$res_name")
			set_res "$G$S"
			S=$((S+1))
		fi
		i=$((i+2))
	done
	eval G${G}_NUM=$((S-1))
}

add_quirk_list() {
	FILE="$BASE_DIR/$CONFIG_PLIST"
	git_url=""
	srce=""
	dest=""
	add_quirks "ACPI" "5"
	add_quirks "Kernel" "6"
	add_quirks "UEFI" "7"
	add_quirks "Booter" "8"
}

set_ROW_COL(){
	case "$G" in
		1|2|3|4)
			ROW=$((S+3))
			COL=$(((G-1)*C+2))
			;;
		5|6|7|8)
			ROW=$((S+BOT+4))
			COL=$(((G-5)*C+2))
			;;
		9)
			ROW=3
			COL=$(((S-1)*C+2))
			;;
	esac
}

set_text_header() {
	res91="ACPI,"
	res92="Kexts/Kernel,"
	res93="Drivers/UEFI,"
	res94="Tools/Booter,"
	G9_NUM="4"
}

set_color() {
	case "$Enabled" in
		true)
			color="$GRN"
			;;
		false)
			color="$RED"
			;;
		dep)
			color="$YEL"
	esac
	if [ "$G" = "9" ];then color="$NC";fi
}

select_MSG() {
	msg "\033[${ROW};${COL}H$color\033[7m$res_name\033[0m"
}

unselect_MSG() {
	msg "\033[${ROW};${COL}H$color$res_name"
}

draw_screen() {
	msg "\033[H$0 $ARG1 $ARG2"
	G=9
	S=1
	BOT=0
	while [ "$S" -lt "5" ]
	do
		get_res "$G$S"
		set_ROW_COL
		msg "\033[${ROW};${COL}H$res_name"
		S=$((S+1))
	done

	G=1
	while [ "$G" -le "8" ]
	do
		S=1
		len="$(eval echo \$G${G}_NUM)"
		if [ "$G" -lt "5" ];then
			if [ "$BOT" -lt "$len" ];then BOT="$len";fi
		fi
		while [ "$S" -le "$len" ]
		do
			get_res "$G$S"
			set_ROW_COL
			set_color
			msg "\033[${ROW};${COL}H$color$res_name$NC"
			S=$((S+1))
		done
		G=$((G+1))
	done
	G=9; S=1; color="$NC"
	set_ROW_COL
	get_res "$G$S"
	select_MSG
}

get_CHAR() {
	stty -icanon
	CHAR=$(dd bs=1 count=1 2>/dev/null|od -A n -a|tr -d ' ')
	stty icanon
}

text_user_interface() {
	msg "\033[2J\033[H"
	R=$(stty size|cut -f1 -d ' '); C=$(stty size|cut -f2 -d ' ')
	C=$((C/4))
	stty -echo
	CHAR=""
	set_text_header
	draw_screen
	while [ "$CHAR" != "g" ]
	do
		get_CHAR
		unselect_MSG
		case $CHAR in
			b)
				S=$(eval echo \$G${G}_NUM)
				if [ "$G" = "9" ];then S=4;fi
				;;
			q)
				msg "\n"
				exit 0
				;;
			t)
				S=1
				;;
			sp|nl)
				if [ "$Enabled" = "true" ];then
					Enabled="false"
				elif [ "$Enabled" = "false" ];then
					Enabled="true"
				fi
				set_res "$G$S"
				;;
			A|k)
				if [ -n "$esc" ] || [ "$CHAR" = "k" ]; then
					if [ "$G" -ne "9" ];then
						S=$((S-1))
						if [ "$S" -eq "0" ];then
							if [ "$G" -gt "4" ];then
								G=$((G-4))
								S="$(eval echo \$G${G}_NUM)"
							else
								S=$G
								G=9
							fi
						fi
					fi
					esc=""
				else
					G=1
				fi
				;;
			B|j)
				if [ -n "$esc" ] || [ "$CHAR" = "j" ]; then
					if [ "$G" -eq "9" ];then
						G=$S
						S=1
					else
						S=$((S+1))
						len="$(eval echo \$G${G}_NUM)"
						if [ "$S" -gt "$len" ];then
							if [ "$G" -lt "5" ];then
								G=$((G+4))
								S=1
							else
								S=$len
							fi
						fi
					fi
				else
					msg "BBBBBBB"
				fi
				esc=""
				;;
			C|l)
				if [ "$G" -eq "9" ];then
					S=$((S+1))
					if [ "$S" -gt "4" ];then S=4;fi
				else
					if [ "$G" -lt "5" ];then
						G=$((G+1))
						if [ "$G" -gt "4" ];then G=4;fi
					else
						G=$((G+1))
						if [ "$G" -gt "8" ];then G=8;fi
					fi
				fi
				esc=""
				;;
			D|h)
				if [ "$G" -eq "9" ];then
					S=$((S-1))
					if [ "$S" -eq "0" ];then S=1;fi
				else
					G=$((G-1))
					if [ "$G" -eq "0" ];then G=1;fi
				fi
				esc=""
				;;
			esc)
				esc="true"
				;;
			*)
				;;
		esac
		if [ "$S" -gt "$(eval echo \$G${G}_NUM)" ];then
			S=$(eval echo \$G${G}_NUM)
		fi
		if [ "$S" -eq "0" ];then S=1; fi
		get_res "$G$S"
		set_ROW_COL
		set_color
		select_MSG
	done
}

#****** Start build ***************
while :
do
	case  "$1" in
	-h) # help
		msg "$(cat "$TOOL_FILES"/help.msg)\n"
		exit 0;;
	-o)
		FINDER="true"
		shift;;
	-q)
		QUIET="-q"
		shift;;
	-u)
		UPDATE="true"
		shift;;
	-v)
		msg "OpenCore-tool version $VER\n"
		exit 0;;
	-T)
		TEXT="true"
		shift;;
	-U)
		UPDATE="stop"
		shift;;
	-V)
		VERBOSE="-v"
		shift;;
	-X)
		if [ -z "$UPDATE" ];then
			msg "Deleting $BASE_DIR/resources ... "
			rm -rf "$BASE_DIR/resources"
			fin
			REMOVE_ALL="true"
		else
			msg "${YEL}WARNING:${NC} not deleting $BASE_DIR/resources since update option selected first\n"
		fi
		shift;;
	--)
		shift; break;;
	esac
done

ARG1="$1"; ARG2="$2"; NOP=""

case $ARG1 in
	b|build) #build first if repo exists, else copy from extras folder
		ARG1="build"
		set_build_type "$ARG2"
		;;
	c|copy) #copy from extras first if exists, else build from repo
		set_build_type "$ARG2"
		ARG1="copy"
		COPY="true"
		;;
	d|debug|r|release)
		msg "${YEL}Usage:${NC} must specify ${U}command${NC} before $ARG1\n"
		exit 1
		;;
	*) #fallthrough - check for options with no command or type
		NOP="true"
esac

if [ -n "$NOP" ];then
	if [ -n "$UPDATE" ]; then # -u option with no following command
		UPDATE="stop"; NOP=""
	fi
	if [ -n "$REMOVE_ALL" ]; then #removed resources no command
		exit 0
	fi
	if [ -n "$TEXT" ];then
		ARG1="build"; ARG2="release"; NOP=""
		set_build_type "release"
	fi
fi

if [ -n "$NOP" ];then
	msg "$(cat "$TOOL_FILES"/usage.msg)\n"
	exit 0
fi

BUILD_DIR="$BASE_DIR/$AUDK_CONFIG/EFI"
CONFIG_PLIST="$AUDK_CONFIG/config.plist"
if [ -n "$FINDER" ]; then FINDER="$BASE_DIR/$AUDK_CONFIG"; fi

if [ -n "$UPDATE" ]; then
	check_for_updates
	if [ "$UPDATE" = "stop" ];then
		if [ -z "$UPDATED" ];then
			msg "${GRN}All resources are up to date.${NC}\n"
		fi
		exit 0
	fi
fi

if [ -z "$VERBOSE" ]; then
	exec 6>&1 #start logging
	exec > $LOGFILE
	exec 2>&1
fi

#FILE="$BASE_DIR/$CONFIG_PLIST"
#msg "$(parse "ACPI" "Quirks" "0")\n"
#msg "$(parse "ACPI" "Quirks" "1")\n"
#msg "$(parse "ACPI" "Quirks" "2")\n"
#msg "$(parse "ACPI" "Quirks" "3")\n"
#msg "$(parse "ACPI" "Quirks" "4")\n"
#exit 0

check_requirements
check_config

init_res_array
add_acpi_res_list
add_tools_res_list
add_drivers_res_list
add_kexts_res_list

if [ -n "$TEXT" ]; then
	add_quirk_list
	text_user_interface
	msg "\033[2J\033[H"
	print_res_array
	exit 0
fi

#swap_res_array

build_resources

set_up_dest_dir
copy_resources

check_if_Sample_plist_updated

build_vault

if [ -z "$VERBOSE" ];then
	exec 1>&6 6>&- 2>&1 #stop logfile
fi

if [ -n "$FINDER" ];then open "$FINDER"; fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n"

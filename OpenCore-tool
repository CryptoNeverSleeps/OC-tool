#!/bin/sh -e

BASE_DIR=$(pwd)
RES_DIR="$BASE_DIR"/resources
TOOL_FILES="$BASE_DIR"/.tool-files
LOGFILE="tool.log"
RED='\033[0;31m'; YEL='\033[1;33m'; GRN='\033[0;32m'
NC='\033[0m' # No Color
B='\033[1m'; U='\033[4m'
VER="1.1p(0911) last checked with OpenCore version DBG-050-2019-09-07"
COPY=""; USE_EXTRAS=""
QUIET=""; VERBOSE=""
UPDATE=""
REMOVE_ALL=""
BASE_TOOLS=""

eval set -- "$(getopt hquvVX "$@")"

msg() {
	if [ -z "$QUIET" ]; then
		echo "$1\c" >"$(tty)"
	fi
}

fin() {
	msg "${GRN}done${NC}\n"
}

missing() {
	msg "\n${RED}ERROR:${NC} $1 must be installed to continue\n"
	exit 1
}

check_requirements() {
	command -v xcodebuild||missing "xcodebuild"
	command -v nasm||missing "nasm"
	command -v mtoc||missing "mtoc"
}

set_up_dest_dir() {
	if [ -d "$BUILD_DIR" ]; then
		msg "Removing old $BUILD_DIR ... "
		rm -rf "$BUILD_DIR"; fin
	fi
	msg "Creating new $BUILD_DIR ... "
	mkdir -p "$BUILD_DIR"/BOOT
	mkdir -p "$BUILD_DIR"/OC
	fin
}

init_res_array() {
	res_num=0
	while read -r line
	do
		res_num=$((res_num+1))
		eval "res$res_num=$line"
	done < "$TOOL_FILES"/base-resources
	base_num=$res_num
}

swap_res() {
	i=1
	while [ "$i" -lt "$res_num" ]
	do
		get_res "$i"
		if [ "$res_name" = "$1" ]; then
			eval temp_res=\$res"$2"
			eval res"$2"=\$res$i
			eval res$i="\$temp_res"
			unset temp_res
			return 1
		fi
		i=$((i+1))
	done
}

swap_res_array() {
	base_num=$((base_num+1))
	swap_res "Lilu.kext" "$base_num"||base_num=$((base_num+1)) #keep Lilu first, must compile before other kexts
	swap_res "VirtualSMC.kext" "$base_num"||base_num=$((base_num+1)) #VirtualSMC must compile before AsusSMC
	swap_res "Shell.efi" "$res_num"||echo "shell swapped to end" #keep Shell last, uses UDK2018
}

clone() {
	if [ -z "$2" ]; then
		pkg_name=$(echo "$1"|rev|cut -f 1 -d /|rev)
	else
		pkg_name="$2"
	fi
	if [ ! -d "$pkg_name" ]; then
		msg "Cloning $1 into $pkg_name ... "
		eval git clone "$1" "$pkg_name"
		fin
		echo "new" > "$pkg_name"/gitDEBUGsha
		echo "new" > "$pkg_name"/gitRELEASEsha
	fi
}

check_config() {
	if [ ! -f "$BASE_DIR/$CONFIG_PLIST" ]; then
		msg "\n${RED}ERROR:${NC} $BASE_DIR/$CONFIG_PLIST does not exist\n\nPlease create this file and run the tool again.\n"
		exit 1
	fi
}

check_for_updates() {
	msg "\nChecking for updates ... \n"
	cd "$BASE_DIR"
	OLDVER=$(git rev-parse HEAD)
	git pull $VERBOSE
	if [ "$OLDVER" != "$(git rev-parse HEAD)" ]; then # new version of OpenCore-tool
		msg "${YEL}INFO:${NC} OpenCore-tool has been updated, run tool again to continue\n"
		exit 0
	fi
	if [ -d "$RES_DIR" ]; then
		cd "$RES_DIR" # now check all other resources
		find . -maxdepth 3 -name .git -type d|rev|cut -c 6-|rev|xargs -I {} git -C {} pull $VERBOSE
	fi
}

make_base_tools() {
	unset WORKSPACE
	unset EDK_TOOLS_PATH
	unset CONF_PATH
# shellcheck disable=SC1091
	. edksetup.sh
	make -C BaseTools
}

build_shell_tool() { #possible to automate this function?
	set_build_type "$build_type"
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/UDK/Build/Shell/$AUDK_BUILD_DIR/X64"
	if [ -f "$srce/Shell.efi" ]; then return 0; fi
	clone "https://github.com/tianocore/edk2 -b UDK2018 --depth=1" "UDK"
	cd UDK
	msg "Making UDK2018 BaseTools ... "
	make_base_tools; fin

	msg "Patching UDK2018 ... "
	for p in ../Patches/* ; do
		git apply "$p"||echo "$p ignored, does not apply or alread done"
	done; fin

	msg "Building $AUDK_CONFIG Shell.efi (OpenCoreShell.efi) ... "
	build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p ShellPkg/ShellPkg.dsc
	fin
}

build_failed() {
	git checkout master
	msg "\n${RED}ERROR:${NC} build failed for $pkg_name\n"
	if [ -z "$VERBOSE" ]; then msg "\tsee $LOGFILE for details\n"; fi
	exit 1
}

build_kext() {
	set_build_type "$build_type"
	mkdir -p "$RES_DIR"/Kext_builds
	cd "$RES_DIR"/Kext_builds
	clone "$git_url"
	cd "$pkg_name"
	srce="$(pwd)/build/$XCODE_CONFIG"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		[ ! -e "$srce/$res_name" ]; then
		msg "Building $AUDK_CONFIG $pkg_name ... "
		rm -rf Lilu.kext # remove Lilu pkg if it came with repo
		if [ ! -L "Lilu.kext" ]; then #link to acidanthera/Lilu debug version
			ln -s "$RES_DIR"/Kext_builds/Lilu/build/Debug/Lilu.kext .
		fi
		if [ ! -L "VirtualSMC.kext" ]; then # AsusSMC needs link to Virtual SMC
			ln -s "$RES_DIR"/Kext_builds/VirtualSMC/build/Debug/VirtualSMC.kext .
		fi
		a=1
		while :
		do
		xcodebuild -config "$XCODE_CONFIG" build && break
			if [ "$a" -eq "6" ]; then return 1; fi
			msg "\n${YEL}$pkg_name TRY $a FAILED:${NC} backing up one commit and trying again\n"
			git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
			msg "Building $pkg_name ... "
			a=$((a+1))
		done
		if [ "$a" -ne "1" ]; then git checkout master; fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
		if [ -d "build/Products" ]; then #copy Products contents back to build level
			cp -r build/Products/* build
		fi
		fin
	fi
}

build_driver() {
	set_build_type "$build_type"
	cd "$RES_DIR"/UDK
	clone "$git_url"
	srce="$(pwd)/Build/$pkg_name/$AUDK_BUILD_DIR/X64"
	cd "$pkg_name"
	if [ "$(git rev-parse HEAD)" != "$(cat git"$AUDK_CONFIG"sha)" ] || \
		{ [ ! -e "$srce/$res_name" ] && [ "$res_name" != "base" ]; }; then
		rm -rf "$srce" # extreme, but does force whole pkg build if a piece is missing
		if [ -f "$pkg_name.dsc" ]; then
			if [ -z "$BASE_TOOLS" ]; then #no need to build again
				msg "Making base tools ... "
				cd ..
				make_base_tools; fin
				cd "$pkg_name"
				BASE_TOOLS="built"
			fi
			a=1
			while :
			do
				msg "Building $AUDK_CONFIG $pkg_name ... "
				build -a X64 -b "$AUDK_CONFIG" -t XCODE5 -p "$pkg_name"/"$pkg_name".dsc && break
				if [ "$a" -eq "5" ]; then return 1; fi
				msg "\n${YEL}$pkg_name TRY $a FAILED:${NC} backing up one commit and trying again\n"
				git checkout "$( git log --oneline -2|cat|tail -1|cut -f1 -d" ")"
				a=$((a+1))
			done
			if [ "$a" -ne "1" ];then git checkout master; fi
			fin
		fi
		git rev-parse HEAD > git"$AUDK_CONFIG"sha
	fi
}

missing_iasl() {
	msg "${RED}ERROR:${NC}\t${B}iasl${NC} command is required to compile $res_name\n\tEither:\t* install iasl, or\n\t\t* place $res_name in ${B}extras${NC} directory\n"
	exit 1
}

build_acpi() {
	pkg_name=$(echo "$res_name"|cut -f1 -d.)
	srce=$RES_DIR/$(echo "$git_url"|rev|cut -f2- -d/|rev)
	if [ -e "$srce/$res_name" ];then
		return 0
	elif [ -e "$RES_DIR/$git_url" ];then
		command -v iasl||missing_iasl
		msg "Building $res_name ... "
		iasl "$RES_DIR/$git_url"||return 1
		fin
	else
		return 1
	fi
}

get_res() {
	res=$(eval echo "\$res$1")
	res_name=$(echo "$res"|cut -f1 -d,)
	git_url=$(echo "$res"|cut -f2 -d,)
	build_type=$(echo "$res"|cut -f3 -d,)
	srce=$(echo "$res"|cut -f4 -d,)
	dest=${res##*,} # special case POSIX compliant - matching the end of res
}

set_res() {
	eval "res$1=$res_name,$git_url,$build_type,$srce,$dest"
}

build_resources() {
	msg "\n${GRN}Building needed or updated resources${NC}\n"
	mkdir -p "$RES_DIR"
	cd "$RES_DIR"

	clone "https://github.com/acidanthera/audk" "UDK"
	i=0
	while [ "$i" -lt "$res_num" ]
	do
		i=$((i+1))
		get_res "$i"
		if [ -z "$srce" ]; then
			case ${res_name##*.} in
			"base" | "efi" )
				if [ "$res_name" = "Shell.efi" ]; then #special case
					build_shell_tool||build_failed
					set_res "$i"
				else
					build_driver||build_failed
					set_res "$i"
				fi
				;;
			"kext" )
				build_kext||build_failed
				set_res "$i"
				;;
			"aml" )
				build_acpi||build_failed
				set_res "$i"
				;;
			esac
		fi
	done
	msg "\n"
}

copy_resources() {
	msg "\n${GRN}Moving ${YEL}$ARG2${GRN} resources into place${NC}\n"
	i=0
	while [ "$i" -lt "$res_num" ]
	do
		i=$((i+1))
		get_res "$i"
		if [ -n "$dest" ]; then
			msg "Copying $res_name to $dest ... "
			mkdir -p "$BUILD_DIR/$dest"
			cp -r "$srce/$res_name" "$BUILD_DIR/$dest"
			fin
		fi
	done
}

config_changed() {
	mkdir -p "$BASE_DIR"/Docs
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist
	cp "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist
	msg "\n${YEL}WARNING:${NC} Sample$1.plist has been updated\n${YEL}!!!${NC} Make sure $BASE_DIR/$CONFIG_PLIST is up to date${NC}.\nRun the tool again if you make any changes.\n"
	cfg_ok="false"
}


check_if_Sample_plist_updated() {
	cfg_ok=""
	msg "\nChecking if config.plist format has changed ... "
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/Sample.plist "$BASE_DIR"/Docs/Sample.plist||config_changed
	cmp --silent "$RES_DIR"/UDK/OpenCorePkg/Docs/SampleFull.plist "$BASE_DIR"/Docs/SampleFull.plist||config_changed "Full"
	if [ -z "$cfg_ok" ]; then fin; fi
}

build_vault() {
	use_vault=$(/usr/libexec/PlistBuddy -c "print :Misc:Security:RequireVault" "$BASE_DIR"/"$CONFIG_PLIST")||use_vault="false"
	if [ "$use_vault" = "true" ]; then
		msg "\nBuilding vault files for $BUILD_DIR ... "
		cd "$BUILD_DIR"/OC
		if ls vault* 1> /dev/null 2>&1; then
			rm vault.*
		fi
		"$RES_DIR"/UDK/OcSupportPkg/Utilities/CreateVault/create_vault.sh .
		make -C "$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool
		"$RES_DIR"/UDK/OcSupportPkg/Utilities/RsaTool/RsaTool -sign vault.plist vault.sig vault.pub
		str=$(strings -a -t d OpenCore.efi | grep "=BEGIN OC VAULT=" | cut -f1 -d" ")
		off=$((str+16))
		dd of=OpenCore.efi if=vault.pub bs=1 seek="$off" count=520 conv=notrunc
		rm vault.pub
		fin
	fi
}

res_not_found() {
	msg "\n${RED}ERROR:${NC}\t$1 - resource was not found in tool-files/repo.plist\n\t$1 file not found in extras directory\n\tPlace $1 file in extras directory to continue\n"
	exit 1
}

add_res_array() {
	git_url=$(/usr/libexec/PlistBuddy -c "print :$res_name" "$TOOL_FILES"/repo.plist)||git_url=""
	if [ -z "$COPY" ] && [ -z "$USE_EXTRAS" ];then
		if [ -n "$git_url" ]; then
			srce=""
		elif [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		else
			res_not_found "$res_name"
		fi
	else # copy mode, check extras folder first
		if [ -e "$BASE_DIR/extras/$res_name" ]; then #found directory (kext) or file (driver)
			srce="$BASE_DIR/extras"
		elif [ -n "$git_url" ]; then
			srce=""
		else
			res_not_found "$res_name"
		fi
		USE_EXTRAS=""
	fi
	res_num=$((res_num+1))
	set_res "$res_num"
}

add_drivers_res_list() {
	i=0
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(/usr/libexec/PlistBuddy -c "print :UEFI:Drivers:$i" "$BASE_DIR"/"$CONFIG_PLIST")||res_name=""
		if [ "$res_name" != "" ]; then
			dest="/OC/Drivers"
			build_type=$ARG2
			add_res_array
		fi
		i=$((i+1))
	done
}

add_kexts_res_list() {
	i=0
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(/usr/libexec/PlistBuddy -c "print :Kernel:Add:$i:BundlePath" "$BASE_DIR"/"$CONFIG_PLIST")||res_name=""
		if [ "$ARG2" != "debug" ];then #need DEBUG dependencies
			if [ "$res_name" = "Lilu.kext" ] || [ "$res_name" = "VirtualSMC.kext" ];then
				build_type="debug"
				dest=""
				add_res_array
			fi
		fi
		Enabled=$(/usr/libexec/PlistBuddy -c "print :Kernel:Add:$i:Enabled" "$BASE_DIR"/"$CONFIG_PLIST")||Enabled=""
		if [ "$Enabled" = "true" ]; then
			build_type=$ARG2
			dest="OC/Kexts"
			add_res_array
		fi
		i=$((i+1))
	done
}

add_tools_res_list() {
	i=0
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(/usr/libexec/PlistBuddy -c "print :Misc:Tools:$i:Path" "$BASE_DIR"/"$CONFIG_PLIST")||res_name=""
		Enabled=$(/usr/libexec/PlistBuddy -c "print :Misc:Tools:$i:Enabled" "$BASE_DIR"/"$CONFIG_PLIST")||Enabled=""
		if [ "$Enabled" = "true" ]; then
			dest="OC/Tools"
			build_type=$ARG2
			add_res_array
		fi
		i=$((i+1))
	done
}

add_acpi_res_list() {
	i=0
	res_name="start"
	until [ -z "$res_name" ]
	do
		res_name=$(/usr/libexec/PlistBuddy -c "print :ACPI:Add:$i:Path" "$BASE_DIR/$CONFIG_PLIST")||res_name=""
		Enabled=$(/usr/libexec/PlistBuddy -c "print :ACPI:Add:$i:Enabled" "$BASE_DIR/$CONFIG_PLIST")||Enabled=""
		if [ "$Enabled" = "true" ]; then
			dest="OC/ACPI"
			build_type=$ARG2
			USE_EXTRAS="true"
			add_res_array
		fi
		i=$((i+1))
	done
}

set_build_type() {
	if [ -z "$build_type" ]; then build_type=$ARG2; fi;
	case $build_type in
		d|debug)
			XCODE_CONFIG="Debug"
			;;
		r|release)
			XCODE_CONFIG="Release"
			;;
		*)
			msg "need to specify ${U}debug${NC} or ${U}release${NC} after $ARG1 command\n"
			exit 1
			;;
	esac
	AUDK_CONFIG=$(echo $XCODE_CONFIG|tr "[:lower:]" "[:upper:]")
	AUDK_BUILD_DIR="${AUDK_CONFIG}_XCODE5"
}


#****** Start build ***************
while :
do
	case  "$1" in
	-h) # help
		msg "$(cat "$TOOL_FILES"/help.msg)\n"
		exit 0;;
	-q)
		QUIET="true"
		shift;;
	-u)
		UPDATE="true"
		shift;;
	-v)
		msg "OpenCore-tool version $VER\n"
		exit 0;;
	-V)
		VERBOSE="-v"
		shift;;

	-X)
		msg "Deleting $BASE_DIR/resources ... "
		rm -rf "$BASE_DIR"/resources
		fin
		REMOVE_ALL="true"
		shift;;
	--)
		shift; break;;
	esac
done

ARG1=$1; ARG2=$2
if [ "$ARG1" = "d" ];then ARG1="debug"; fi # ensure Lilu prerec is met
if [ "$ARG2" = "d" ];then ARG2="debug"; fi # and move output looks nice
if [ "$ARG1" = "r" ];then ARG1="release"; fi
if [ "$ARG2" = "r" ]; then ARG2="release"; fi

case $ARG1 in
	b|build) #build first if repo exists, else copy from extras folder
		set_build_type "$ARG2"
		;;
	c|copy) #copy from extras first if exists, else build from repo
		set_build_type "$ARG2"
		COPY="true"
		;;
	d|debug|r|release)
		msg "${YEL}Usage:${NC} must specify ${U}command${NC} before $ARG1\n"
		exit 1
		;;
	*) #fallthrough - check for options with no command or type
		if [ -n "$UPDATE" ]; then # -u option with no following command
			check_for_updates
			exit 0
		fi
		if [ -n "$REMOVE_ALL" ]; then #removed resources no command
			exit 0
		fi

		msg "$(cat "$TOOL_FILES"/usage.msg)\n"
		exit 0
		;;
esac

BUILD_DIR="$BASE_DIR/$AUDK_CONFIG/EFI"
CONFIG_PLIST="$AUDK_CONFIG/config.plist"

if [ -n "$UPDATE" ]; then
	check_for_updates
fi

if [ -z "$VERBOSE" ]; then
	exec 6>&1 #start logging
	exec > $LOGFILE
	exec 2>&1
fi
check_requirements
check_config

init_res_array
add_acpi_res_list
add_tools_res_list
add_drivers_res_list
add_kexts_res_list

swap_res_array

build_resources

set_up_dest_dir
copy_resources

check_if_Sample_plist_updated

build_vault

if [ -z "$VERBOSE" ];then
	exec 1>&6 6>&- 2>&1 #stop logfile
fi

msg "\n${GRN}Finished building ${YEL}$BUILD_DIR${NC}\n"
